{"ast":null,"code":"var _jsxFileName = \"/home/gal98/projects/pocket-cube-solver/frontend/src/components/Cube.js\",\n  _s = $RefreshSig$();\n/* eslint-disable default-case */\nimport React, { useState, useEffect } from \"react\";\nimport \"./Cube.css\";\nimport API_BASE_URL from \"../config\";\n\n// const defaultColors = {\n//   U: \"blue\",   // Up\n//   D: \"green\",  // Down\n//   F: \"orange\", // Front\n//   B: \"red\",    // Back\n//   L: \"white\",  // Left\n//   R: \"yellow\", // Right\n// };\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialCubeState = [{\n  id: \"UBL\",\n  position: [-1, 1, -1],\n  colors: {\n    U: \"blue\",\n    B: \"red\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"UBR\",\n  position: [1, 1, -1],\n  colors: {\n    U: \"blue\",\n    B: \"red\",\n    R: \"white\"\n  }\n}, {\n  id: \"UFL\",\n  position: [-1, 1, 1],\n  colors: {\n    U: \"blue\",\n    F: \"orange\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"UFR\",\n  position: [1, 1, 1],\n  colors: {\n    U: \"blue\",\n    F: \"orange\",\n    R: \"white\"\n  }\n}, {\n  id: \"DBL\",\n  position: [-1, -1, -1],\n  colors: {\n    D: \"green\",\n    B: \"red\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"DBR\",\n  position: [1, -1, -1],\n  colors: {\n    D: \"green\",\n    B: \"red\",\n    R: \"white\"\n  }\n}, {\n  id: \"DFL\",\n  position: [-1, -1, 1],\n  colors: {\n    D: \"green\",\n    F: \"orange\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"DFR\",\n  position: [1, -1, 1],\n  colors: {\n    D: \"green\",\n    F: \"orange\",\n    R: \"white\"\n  }\n}];\n\n// Helper that decides exactly which layer to rotate, given the face clicked\n// and the (x,y,z) position of that cubie.\nfunction getLayerFromFaceAndPosition(face, x, y, z) {\n  // Convert to integers, since dataset attributes come as strings\n  x = parseInt(x, 10);\n  y = parseInt(y, 10);\n  z = parseInt(z, 10);\n  switch (face) {\n    case \"U\":\n      // Only rotate top layer if y=1\n      return y === 1 ? \"U\" : null;\n    case \"D\":\n      // Only rotate bottom layer if y=-1\n      return y === -1 ? \"D\" : null;\n    case \"F\":\n      // Only rotate front layer if z=1\n      return z === 1 ? \"F\" : null;\n    case \"B\":\n      // Only rotate back layer if z=-1\n      return z === -1 ? \"B\" : null;\n    case \"R\":\n      // Only rotate right layer if x=1\n      return x === 1 ? \"R\" : null;\n    case \"L\":\n      // Only rotate left layer if x=-1\n      return x === -1 ? \"L\" : null;\n    default:\n      return null;\n  }\n}\nconst Cube = () => {\n  _s();\n  const [cubeState, setCubeState] = useState(initialCubeState);\n  const [shouldSolve, setShouldSolve] = useState(false);\n  const [rotation, setRotation] = useState({\n    x: -30,\n    y: 45\n  }); // Whole-cube rotation\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({\n    x: 0,\n    y: 0\n  });\n  const [selectedLayer, setSelectedLayer] = useState(null);\n  const [solutionSteps, setSolutionSteps] = useState([]);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [guideMode, setGuideMode] = useState(false);\n\n  // --- MOUSE EVENTS ---\n  const handleMouseDown = event => {\n    // 1) Check if you clicked on a specific face via data-face\n    const faceElement = event.target.closest(\".cubie-face\");\n    if (faceElement) {\n      const face = faceElement.dataset.face; // e.g., \"U\", \"R\", ...\n      if (face) {\n        // Grab the parent .cubie to read its data-x, data-y, data-z\n        const cubieEl = faceElement.closest(\".cubie\");\n        if (cubieEl) {\n          const {\n            x,\n            y,\n            z\n          } = cubieEl.dataset;\n          // Figure out the *actual* layer to rotate, if any\n          const layer = getLayerFromFaceAndPosition(face, x, y, z);\n          if (layer) {\n            setSelectedLayer(layer);\n            setDragStart({\n              x: event.clientX,\n              y: event.clientY\n            });\n            return; // Skip rotating the whole cube\n          }\n        }\n      }\n    }\n\n    // 2) Otherwise, rotate the entire cube\n    setIsDragging(true);\n    setDragStart({\n      x: event.clientX,\n      y: event.clientY\n    });\n    document.body.style.cursor = \"grabbing\";\n  };\n  const handleMouseMove = event => {\n    // A) If dragging the whole cube\n    const MAX_ROTATION_X = 90; // Maximum x rotation\n    const MIN_ROTATION_X = -90; // Minimum x rotation\n\n    if (isDragging) {\n      const deltaX = event.clientX - dragStart.x;\n      const deltaY = event.clientY - dragStart.y;\n\n      // Update x with the deltaY, but clamp it between MIN_ROTATION_X and MAX_ROTATION_X\n      setRotation(prev => {\n        const newX = prev.x - deltaY * 0.3;\n        const newY = prev.y + deltaX * 0.3;\n        return {\n          x: Math.max(MIN_ROTATION_X, Math.min(newX, MAX_ROTATION_X)),\n          // Clamp x\n          y: newY\n        };\n      });\n      setDragStart({\n        x: event.clientX,\n        y: event.clientY\n      });\n    }\n    if (!guideMode) {\n      // B) If dragging a face to rotate that layer\n      if (selectedLayer) {\n        const deltaX = event.clientX - dragStart.x;\n        if (Math.abs(deltaX) > 30) {\n          const direction = deltaX > 0 ? 90 : -90;\n          rotateLayerCubies(selectedLayer, direction);\n          setSelectedLayer(null); // Prevent repeated rotations on same drag\n        }\n      }\n    } else {\n      const expectedLayer = solutionSteps[currentStepIndex];\n      if (selectedLayer === expectedLayer) {\n        const deltaX = event.clientX - dragStart.x;\n        const direction = deltaX > 0 ? 90 : -90;\n        let validRotate = false;\n        if ((selectedLayer === \"U\" || selectedLayer === \"F\" || selectedLayer === \"R\" || selectedLayer === \"D\") && direction === 90) {\n          validRotate = true;\n        }\n        if ((selectedLayer === \"B\" || selectedLayer === \"L\") && direction === -90) {\n          validRotate = true;\n        }\n        if (Math.abs(deltaX) > 30 && validRotate) {\n          //const direction = deltaX > 0 ? 90 : -90;\n          rotateLayerCubies(selectedLayer, direction);\n          setSelectedLayer(null); // Prevent repeated rotations on same drag\n          handleUserRotationDone();\n          validRotate = false;\n        }\n      }\n    }\n  };\n\n  // // Determine arrow direction\n  // let direction = 90;\n  // if (layer === \"B\" || layer === \"L\") {\n  //   direction = -90;\n  // }\n\n  const handleMouseUp = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n  const handleMouseLeave = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n  const rotateLayerCubies = (layer, direction) => {\n    setCubeState(prevState => {\n      const newState = [...prevState];\n      let axisIndex, axisValue;\n      switch (layer) {\n        case \"U\":\n          axisIndex = 1; // y\n          axisValue = 1;\n          break;\n        case \"D\":\n          axisIndex = 1;\n          axisValue = -1;\n          break;\n        case \"F\":\n          axisIndex = 2; // z\n          axisValue = 1;\n          break;\n        case \"B\":\n          axisIndex = 2;\n          axisValue = -1;\n          break;\n        case \"R\":\n          axisIndex = 0; // x\n          axisValue = 1;\n          break;\n        case \"L\":\n          axisIndex = 0;\n          axisValue = -1;\n          break;\n        default:\n          return newState;\n      }\n      const affectedCubies = newState.filter(c => c.position[axisIndex] === axisValue);\n\n      // // Helper to update a sticker only if it exists.\n      // const updateColor = (colors, target, value) => {\n      //   return colors.hasOwnProperty(target) ? value : undefined;\n      // };\n\n      const rotateCubie = cubie => {\n        const {\n          position,\n          colors\n        } = cubie;\n        const [x, y, z] = position;\n        let newPosition = [...position];\n        let newColors = {\n          ...colors\n        };\n\n        // Helper function: assign oldFace to newFace if oldFace existed, then delete oldFace\n        const reassignFace = (oldFace, newFace) => {\n          if (colors[oldFace]) {\n            newColors[newFace] = colors[oldFace];\n            //delete newColors[oldFace];\n          }\n        };\n        switch (layer) {\n          case \"U\":\n            if (direction > 0) {\n              // +90 around U\n              newPosition = [z, y, -x];\n              // Keep U face\n              if (colors.U) newColors.U = colors.U;\n\n              //F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"R\", \"B\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"L\", \"F\");\n            } else {\n              // -90 around U\n              newPosition = [-z, y, x];\n              if (colors.U) newColors.U = colors.U;\n\n              // F->L, L->B, B->R, R->F (the reverse mapping)\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"L\", \"B\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"R\", \"F\");\n            }\n            break;\n          case \"D\":\n            if (direction > 0) {\n              newPosition = [z, y, -x];\n              if (colors.D) newColors.D = colors.D;\n\n              // F->L, L->B, B->R, R->F (for example)\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"L\", \"F\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"R\", \"B\");\n            } else {\n              newPosition = [-z, y, x];\n              if (colors.D) newColors.D = colors.D;\n\n              // F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"R\", \"F\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"L\", \"B\");\n            }\n            break;\n          case \"F\":\n            if (direction > 0) {\n              newPosition = [y, -x, z];\n              if (colors.F) newColors.F = colors.F;\n\n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            } else {\n              newPosition = [-y, x, z];\n              if (colors.F) newColors.F = colors.F;\n\n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            }\n            break;\n          case \"B\":\n            if (direction > 0) {\n              newPosition = [-y, x, z];\n              if (colors.B) newColors.B = colors.B;\n\n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            } else {\n              newPosition = [y, -x, z];\n              if (colors.B) newColors.B = colors.B;\n\n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            }\n            break;\n          case \"R\":\n            if (direction > 0) {\n              newPosition = [x, z, -y];\n              if (colors.R) newColors.R = colors.R;\n\n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            } else {\n              newPosition = [x, -z, y];\n              if (colors.R) newColors.R = colors.R;\n\n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            }\n            break;\n          case \"L\":\n            if (direction > 0) {\n              newPosition = [x, -z, y];\n              if (colors.L) newColors.L = colors.L;\n\n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            } else {\n              newPosition = [x, z, -y];\n              if (colors.L) newColors.L = colors.L;\n\n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            }\n            break;\n        }\n        return {\n          ...cubie,\n          position: newPosition,\n          colors: newColors\n        };\n      };\n      const updated = {};\n      affectedCubies.forEach(cubie => {\n        updated[cubie.id] = rotateCubie(cubie);\n      });\n      return newState.map(c => updated[c.id] || c);\n    });\n  };\n  const scrambleCube = async () => {\n    // Decide how many random moves you want:\n    const SCRAMBLE_LENGTH = 15; // or 20, etc.\n\n    const faces = [\"U\", \"D\", \"L\", \"R\", \"F\", \"B\"];\n    const directions = [90, -90]; // clockwise or counterclockwise\n\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms)); // Delay function\n\n    for (let i = 0; i < SCRAMBLE_LENGTH; i++) {\n      const randomFace = faces[Math.floor(Math.random() * faces.length)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n\n      // rotateLayerCubies is your existing method to do 90° turns\n      rotateLayerCubies(randomFace, randomDir);\n\n      // Wait for a timeout before the next move (e.g., 300ms between moves)\n      await delay(300);\n    }\n  };\n  const flattenCubeStateByPosition = cubeState => {\n    // Convert color strings to single-letter codes\n    const getColorLetter = color => {\n      const colorMap = {\n        white: \"W\",\n        yellow: \"Y\",\n        blue: \"B\",\n        green: \"G\",\n        red: \"R\",\n        orange: \"O\"\n      };\n      return colorMap[color] || \"?\";\n    };\n\n    // ========== U FACE ========== \n    // y === 1, have a U sticker\n    const getUIndex = cubie => {\n      const [x, _, z] = cubie.position;\n      // Example: top-left => 0, top-right => 1, bottom-left => 2, bottom-right => 3\n      // Fill in the coordinates that physically match each slot.\n      // (Just like your existing getUIndex)\n      if (x === 1 && z === -1) return 2;\n      if (x === -1 && z === -1) return 3;\n      if (x === 1 && z === 1) return 0;\n      if (x === -1 && z === 1) return 1;\n      return 99;\n    };\n\n    // ========== D FACE ========== \n    // y === -1, have a D sticker\n    const getDIndex = cubie => {\n      const [x, _, z] = cubie.position;\n      // TODO: Decide how you'd like to label D's top-left => 0, top-right => 1, etc.\n      // For instance:\n      // if (x=-1,z=-1) => 0, (x=1,z=-1) => 1, (x=-1,z=1) => 2, (x=1,z=1) => 3\n      // or any arrangement that yields the correct “visual” order for D.\n      if (x === -1 && z === -1) return 2;\n      if (x === 1 && z === -1) return 3;\n      if (x === -1 && z === 1) return 0;\n      if (x === 1 && z === 1) return 1;\n      return 99;\n    };\n\n    // ========== F FACE ==========\n    const getFIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // y is your vertical axis, x is left-right, z=1 for front\n      // Decide which coordinate combos map to top-left => 0, top-right => 1, etc.\n      // Example:\n      // if (y=1, x=-1) => 0, (y=1, x=1) => 1, (y=-1, x=-1) => 2, (y=-1, x=1) => 3\n      // So you end up with top row = y=1, bottom row = y=-1, left col = x=-1, right col = x=1\n      if (y === 1 && x === -1) return 0;\n      if (y === 1 && x === 1) return 1;\n      if (y === -1 && x === -1) return 2;\n      if (y === -1 && x === 1) return 3;\n      return 99;\n    };\n\n    // ========== B FACE ==========\n    const getBIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // Similar logic for the back face (z=-1).\n      // If you want top-left => y=1,x=1 => 0, etc., fill it in:\n      if (y === 1 && x === 1) return 0;\n      if (y === 1 && x === -1) return 1;\n      if (y === -1 && x === 1) return 2;\n      if (y === -1 && x === -1) return 3;\n      return 99;\n    };\n\n    // ========== L FACE ==========\n    const getLIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // x = -1 for left\n      // Decide top-left => (?), top-right => (?), bottom-left => (?), etc.\n      // Possibly y=1 => top, z=-1 => left, etc.\n      if (y === 1 && z === 1) return 1;\n      if (y === 1 && z === -1) return 0;\n      if (y === -1 && z === 1) return 3;\n      if (y === -1 && z === -1) return 2;\n      return 99;\n    };\n\n    // ========== R FACE ==========\n    const getRIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // x=+1 for right\n      // Fill in your top-left -> index0, top-right -> index1, etc.\n      if (y === 1 && z === -1) return 1;\n      if (y === 1 && z === 1) return 0;\n      if (y === -1 && z === -1) return 3;\n      if (y === -1 && z === 1) return 2;\n      return 99;\n    };\n\n    // The main function to get stickers for each face:\n    const getFaceStickers = face => {\n      let filtered = [];\n      switch (face) {\n        case \"U\":\n          {\n            filtered = cubeState.filter(c => c.position[1] === 1 && c.colors.U);\n            filtered.sort((a, b) => getUIndex(a) - getUIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.U)).join(\"\");\n          }\n        case \"D\":\n          {\n            filtered = cubeState.filter(c => c.position[1] === -1 && c.colors.D);\n            filtered.sort((a, b) => getDIndex(a) - getDIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.D)).join(\"\");\n          }\n        case \"F\":\n          {\n            filtered = cubeState.filter(c => c.position[2] === 1 && c.colors.F);\n            filtered.sort((a, b) => getFIndex(a) - getFIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.F)).join(\"\");\n          }\n        case \"B\":\n          {\n            filtered = cubeState.filter(c => c.position[2] === -1 && c.colors.B);\n            filtered.sort((a, b) => getBIndex(a) - getBIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.B)).join(\"\");\n          }\n        case \"L\":\n          {\n            filtered = cubeState.filter(c => c.position[0] === -1 && c.colors.L);\n            filtered.sort((a, b) => getLIndex(a) - getLIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.L)).join(\"\");\n          }\n        case \"R\":\n          {\n            filtered = cubeState.filter(c => c.position[0] === 1 && c.colors.R);\n            filtered.sort((a, b) => getRIndex(a) - getRIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.R)).join(\"\");\n          }\n        default:\n          return \"\";\n      }\n    };\n\n    // Flatten in the face order your solver expects\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    return faceOrder.map(face => getFaceStickers(face)).join(\"\");\n  };\n\n  // const checkSymmetryAndSolve = async () => {\n  //   // 1) Flatten the user’s current cube state\n  //   console.log(\"Cube state original format - Before update:\" , cubeState);\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   console.log(\"Flattened Cube String:\", cubeString);\n\n  //   try {\n  //     // 2) Call your /find_symmetry endpoint first\n  //     const res = await fetch(`${API_BASE_URL}/find_symmetry`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await res.json();\n\n  //     if (!data.found) {\n  //       console.log(\"No matching or symmetrical version found. Cannot solve.\");\n  //       return; // or show a UI error\n  //     }\n\n  //     // If found == true\n  //     if (data.state !== cubeString) {\n  //       // Means we have a symmetrical match that differs from the user's state\n  //       console.log(\"Server suggests symmetrical reorientation:\", data.state);\n  //       // 3) Reorient the cube to that symmetrical version\n  //       reorientCubeFromString(data.state);\n  //     }\n\n  //     else {\n  //       // If no reorientation is needed, we can still trigger the solver:\n  //       setShouldSolve(true);\n  //     }\n\n  //   } catch (err) {\n  //     console.error(\"Error checking symmetry:\", err);\n  //   }\n  // }\n\n  //   // useEffect to call solver after state is updated\n  // useEffect(() => {\n  //   if (shouldSolve) {\n  //     callSolveEndpoint(); // uses the *latest* cubeState\n  //     setShouldSolve(false);\n  //   }\n  // }, [cubeState, shouldSolve]);\n\n  // Example: callSolveEndpoint references your existing handleSolve logic\n  // const callSolveEndpoint = async () => {\n  //   console.log(\"Cube state original format - after update:\" , cubeState);\n\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   //const finalString = flattenCubeStateByPosition(cubeState);\n  //   // the existing logic from handleSolve\n  //   console.log(\"Cube state string - after upadate: \", cubeString);\n\n  //   try {\n  //     const response = await fetch(`${API_BASE_URL}/solve`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await response.json();\n  //     if (!data) {\n  //       console.log(\"no matching solution found\");\n  //       return;\n  //     }\n  //     guideUserThroughSolution(data.solution);\n  //   } catch (error) {\n  //     console.error(\"Error solving:\", error);\n  //   }\n  // };\n\n  function createBlankCubeState() {\n    return [{\n      id: \"UBL\",\n      position: [-1, 1, -1],\n      colors: {}\n    }, {\n      id: \"UBR\",\n      position: [1, 1, -1],\n      colors: {}\n    }, {\n      id: \"UFL\",\n      position: [-1, 1, 1],\n      colors: {}\n    }, {\n      id: \"UFR\",\n      position: [1, 1, 1],\n      colors: {}\n    }, {\n      id: \"DBL\",\n      position: [-1, -1, -1],\n      colors: {}\n    }, {\n      id: \"DBR\",\n      position: [1, -1, -1],\n      colors: {}\n    }, {\n      id: \"DFL\",\n      position: [-1, -1, 1],\n      colors: {}\n    }, {\n      id: \"DFR\",\n      position: [1, -1, 1],\n      colors: {}\n    }];\n  }\n  function reorientCubeFromString(cubeString) {\n    // We'll parse 24 characters in blocks of 4 for U,D,F,B,R,L\n    // For each block, we figure out which cubies get which face color\n\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    // A helper to convert a single letter like 'B' or 'O' back to e.g. \"blue\" or \"orange\"\n    const colorMapReverse = {\n      \"W\": \"white\",\n      \"Y\": \"yellow\",\n      \"B\": \"blue\",\n      \"G\": \"green\",\n      \"R\": \"red\",\n      \"O\": \"orange\"\n    };\n\n    // 1) Create a blank 8-cubie array\n    let newState = createBlankCubeState();\n\n    // 2) Define the “index → coordinate” for each face\n    const getUCoordinateByIndex = i => {\n      // Inverse of your getUIndex. \n      switch (i) {\n        case 2:\n          return [1, 1, -1];\n        // x=1,z=-1\n        case 3:\n          return [-1, 1, -1];\n        // x=-1,z=-1\n        case 0:\n          return [1, 1, 1];\n        // x=1,z=1\n        case 1:\n          return [-1, 1, 1];\n        // x=-1,z=1\n        default:\n          return \" \";\n      }\n    };\n    const getDCoordinateByIndex = i => {\n      switch (i) {\n        case 2:\n          return [-1, -1, -1];\n        case 3:\n          return [1, -1, -1];\n        case 0:\n          return [-1, -1, 1];\n        case 1:\n          return [1, -1, 1];\n        default:\n          return \" \";\n      }\n    };\n    const getFCoordinateByIndex = i => {\n      switch (i) {\n        case 0:\n          return [-1, 1, 1];\n        case 1:\n          return [1, 1, 1];\n        case 2:\n          return [-1, -1, 1];\n        case 3:\n          return [1, -1, 1];\n        default:\n          return \" \";\n      }\n    };\n    const getBCoordinateByIndex = i => {\n      switch (i) {\n        case 0:\n          return [1, 1, -1];\n        case 1:\n          return [-1, 1, -1];\n        case 2:\n          return [1, -1, -1];\n        case 3:\n          return [-1, -1, -1];\n        default:\n          return \" \";\n      }\n    };\n    const getLCoordinateByIndex = i => {\n      switch (i) {\n        case 1:\n          return [-1, 1, 1];\n        case 0:\n          return [-1, 1, -1];\n        case 3:\n          return [-1, -1, 1];\n        case 2:\n          return [-1, -1, -1];\n        default:\n          return \" \";\n      }\n    };\n    const getRCoordinateByIndex = i => {\n      switch (i) {\n        case 1:\n          return [1, 1, -1];\n        case 0:\n          return [1, 1, 1];\n        case 3:\n          return [1, -1, -1];\n        case 2:\n          return [1, -1, 1];\n        default:\n          return \" \";\n      }\n    };\n    // Similarly define getFCoordinateByIndex, getBCoordinateByIndex, etc...\n    // matching how you set up getFIndex, getBIndex, etc.\n\n    // 3) A helper that finds the cubie in newState that matches a coordinate\n    function findCubieByPosition(x, y, z) {\n      return newState.find(c => c.position[0] === x && c.position[1] === y && c.position[2] === z);\n    }\n\n    // 4) Parse the cubeString in 6 chunks of 4\n    let offset = 0;\n    for (let face of faceOrder) {\n      const faceChars = cubeString.slice(offset, offset + 4); // next 4 letters\n      offset += 4;\n      for (let i = 0; i < 4; i++) {\n        const letter = faceChars[i]; // e.g. 'B', 'O', 'W'\n        const colorString = colorMapReverse[letter] || \"unknown\";\n        let xyz;\n        if (face === \"U\") {\n          xyz = getUCoordinateByIndex(i);\n        } else if (face === \"D\") {\n          xyz = getDCoordinateByIndex(i);\n        } else if (face === \"F\") {\n          xyz = getFCoordinateByIndex(i);\n        } else if (face === \"B\") {\n          xyz = getBCoordinateByIndex(i);\n        } else if (face === \"R\") {\n          xyz = getRCoordinateByIndex(i);\n        } else if (face === \"L\") {\n          xyz = getLCoordinateByIndex(i);\n        }\n        const [x, y, z] = xyz;\n        // find the matching cubie\n        const cubie = findCubieByPosition(x, y, z);\n        if (cubie) {\n          cubie.colors[face] = colorString;\n        }\n      }\n    }\n    // fill in newState\n    setCubeState(newState);\n\n    // Also set a flag\n    //setShouldSolve(true);\n  }\n\n  // 1) \"Find Solution\" button\n  const handleFindSolution = async () => {\n    const cubeString = flattenCubeStateByPosition(cubeState);\n    try {\n      // Check for symmetry\n      const symmetryRes = await fetch(`${API_BASE_URL}/find_symmetry`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          cube_data: cubeString\n        })\n      });\n      const symmetryData = await symmetryRes.json();\n      if (!symmetryData.found) {\n        console.log(\"No symmetrical version found. Can't solve.\");\n        setSolutionSteps(null);\n        return;\n      }\n\n      // If we got a symmetrical match, reorient the cube\n      if (symmetryData.state !== cubeString) {\n        reorientCubeFromString(symmetryData.state);\n        console.log(\"notice: cube switch to identical symmetic state - adapt your cube with this symmetrica state\");\n      }\n\n      // Now request the solution steps from /solve\n      const solveRes = await fetch(`${API_BASE_URL}/solve`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          cube_data: symmetryData.state\n        })\n      });\n      const solveData = await solveRes.json();\n      if (solveData.solution[0] === \"Congratulations!\") {\n        console.log(\"Cube is already in its solved state\");\n        setSolutionSteps(null);\n        return;\n      }\n      setSolutionSteps(solveData.solution);\n      console.log(\"Solution steps are ready. Click 'Guide Me' to start solving.\");\n    } catch (err) {\n      console.error(\"Error finding or solving:\", err);\n    }\n  };\n\n  // 2) \"Guide Me\" button\n  const handleGuideMe = () => {\n    if (!solutionSteps || solutionSteps.length === 0) {\n      console.log(\"No solution steps. Click 'Find Solution' first.\");\n      return;\n    }\n    // Start from the first move\n    setGuideMode(true);\n    setCurrentStepIndex(0);\n    showManualStep(0);\n  };\n\n  // const guideUserThroughSolution = async (solutionMoves) => {\n  //   for (const layer of solutionMoves) {\n\n  //     if (layer === \"Congratulations!\") {\n  //       console.log(\"Done!\");\n  //       return;\n  //     }\n\n  //     let direction = 90;\n  //     if (layer === \"B\" || layer === \"L\") {\n  //       direction = -90;\n  //     }\n  //     // Show guidance with an arrow\n  //     showArrowOnFace(layer, direction);\n\n  //     // Wait before animating the move\n  //     await delay(1000);  // 1-second pause before executing the move\n\n  //     // Perform the rotation (animate and update state)\n  //     rotateLayerCubies(layer, direction);\n\n  //     // Remove the arrow after the move\n  //     removeArrowFromFace(layer);\n\n  //     // Wait before moving to the next step\n  //     await delay(1000);\n  //   }\n\n  //   // Final success message\n  //   showSuccessMessage();\n  // };\n\n  const showManualStep = index => {\n    // If we’re beyond the last move, show success\n    if (index >= solutionSteps.length) {\n      showSuccessMessage();\n      return;\n    }\n    const layer = solutionSteps[index];\n    // If it's some special marker like \"Congratulations!\"\n    if (layer === \"Congratulations!\") {\n      showSuccessMessage();\n      setGuideMode(false);\n      return;\n    }\n\n    // Determine arrow direction\n    let direction = 90;\n    if (layer === \"B\" || layer === \"L\") {\n      direction = -90;\n    }\n\n    // Display the arrow on the correct face\n    showArrowsOnLayer(layer, direction);\n\n    // Now we wait for the user to rotate manually...\n    // The user will click \"Next\" or some UI button once they’ve done the move\n  };\n  const handleUserRotationDone = () => {\n    // Remove the arrow from the current face\n    const layer = solutionSteps[currentStepIndex];\n    removeArrowsFromLayer(layer);\n\n    // Move on to the next step\n    const nextIndex = currentStepIndex + 1;\n    setCurrentStepIndex(nextIndex);\n    showManualStep(nextIndex);\n  };\n  const showArrowsOnLayer = (layer, direction) => {\n    setTimeout(() => {\n      // Grab all .cubie-face elements whose data-face matches\n      const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n      faceElements.forEach(face => {\n        // Create the arrow element\n        const arrow = document.createElement(\"div\");\n        arrow.classList.add(\"rotation-arrow\");\n        if (layer === \"U\") {\n          arrow.innerHTML = direction < 0 ? \"↻\" : \"↺\";\n        } else {\n          arrow.innerHTML = direction > 0 ? \"↻\" : \"↺\";\n        }\n\n        // Append the arrow to the face\n        face.appendChild(arrow);\n      });\n    }, 200); // Delay of 200ms; adjust as needed\n  };\n\n  // Remove arrows from every face in that layer\n  const removeArrowsFromLayer = layer => {\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n    faceElements.forEach(face => {\n      const arrow = face.querySelector(\".rotation-arrow\");\n      if (arrow) arrow.remove();\n    });\n  };\n  const showSuccessMessage = () => {\n    const messageBox = document.createElement(\"div\");\n    messageBox.classList.add(\"success-message\");\n    messageBox.innerText = \"🎉 Cube Solved!\";\n    document.body.appendChild(messageBox);\n    setTimeout(() => {\n      messageBox.remove(); // Remove after 3 seconds\n    }, 3000);\n  };\n  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  // --- RENDERING ---\n  const renderCubies = () => cubeState.map(cubie => {\n    const {\n      id,\n      position,\n      colors\n    } = cubie;\n    const [cx, cy, cz] = position;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"cubie\",\n      \"data-x\": cx // So we can read them on click\n      ,\n      \"data-y\": cy,\n      \"data-z\": cz,\n      style: {\n        position: \"absolute\",\n        width: \"88px\",\n        height: \"88px\",\n        transform: `translate3d(${cx * 45}px, ${-cy * 45}px, ${cz * 45}px)`,\n        transformStyle: \"preserve-3d\"\n      },\n      children: Object.entries(colors).map(([face, color]) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"cubie-face\",\n        \"data-face\": face // e.g., \"U\", \"D\", \"F\", etc.\n        ,\n        style: {\n          position: \"absolute\",\n          width: \"80px\",\n          height: \"80px\",\n          border: \"8px solid black\",\n          backgroundColor: color,\n          transform: getFaceTransform(face),\n          cursor: \"pointer\"\n        }\n      }, face, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1054,\n        columnNumber: 13\n      }, this))\n    }, id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1039,\n      columnNumber: 9\n    }, this);\n  });\n\n  // Places each face in the correct orientation\n  const getFaceTransform = face => {\n    switch (face) {\n      case \"U\":\n        return \"rotateX(90deg) translateZ(45px)\";\n      case \"D\":\n        return \"rotateX(-90deg) translateZ(45px)\";\n      case \"F\":\n        return \"translateZ(45px)\";\n      case \"B\":\n        return \"rotateY(180deg) translateZ(45px)\";\n      case \"L\":\n        return \"rotateY(-90deg) translateZ(45px)\";\n      case \"R\":\n        return \"rotateY(90deg) translateZ(45px)\";\n      default:\n        return \"\";\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"button-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"scramble\",\n        onClick: scrambleCube,\n        children: \"Scramble\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1098,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"find-solution\",\n        onClick: handleFindSolution,\n        children: \"Find Solution\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1099,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"guide-me\",\n        onClick: handleGuideMe,\n        children: \"Guide Me\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1100,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1097,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"cube-container\",\n      onMouseDown: handleMouseDown,\n      onMouseMove: handleMouseMove,\n      onMouseUp: handleMouseUp,\n      onMouseLeave: handleMouseLeave,\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"cube\",\n        style: {\n          transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`\n        },\n        children: renderCubies()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1109,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1102,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1096,\n    columnNumber: 5\n  }, this);\n};\n_s(Cube, \"uUkUJ9cGkrWSgSy08BLNSMmv/Ko=\");\n_c = Cube;\nexport default Cube; // Export the Cube component\nvar _c;\n$RefreshReg$(_c, \"Cube\");","map":{"version":3,"names":["React","useState","useEffect","API_BASE_URL","jsxDEV","_jsxDEV","initialCubeState","id","position","colors","U","B","L","R","F","D","getLayerFromFaceAndPosition","face","x","y","z","parseInt","Cube","_s","cubeState","setCubeState","shouldSolve","setShouldSolve","rotation","setRotation","isDragging","setIsDragging","dragStart","setDragStart","selectedLayer","setSelectedLayer","solutionSteps","setSolutionSteps","currentStepIndex","setCurrentStepIndex","guideMode","setGuideMode","handleMouseDown","event","faceElement","target","closest","dataset","cubieEl","layer","clientX","clientY","document","body","style","cursor","handleMouseMove","MAX_ROTATION_X","MIN_ROTATION_X","deltaX","deltaY","prev","newX","newY","Math","max","min","abs","direction","rotateLayerCubies","expectedLayer","validRotate","handleUserRotationDone","handleMouseUp","handleMouseLeave","prevState","newState","axisIndex","axisValue","affectedCubies","filter","c","rotateCubie","cubie","newPosition","newColors","reassignFace","oldFace","newFace","updated","forEach","map","scrambleCube","SCRAMBLE_LENGTH","faces","directions","delay","ms","Promise","resolve","setTimeout","i","randomFace","floor","random","length","randomDir","flattenCubeStateByPosition","getColorLetter","color","colorMap","white","yellow","blue","green","red","orange","getUIndex","_","getDIndex","getFIndex","getBIndex","getLIndex","getRIndex","getFaceStickers","filtered","sort","a","b","join","faceOrder","createBlankCubeState","reorientCubeFromString","cubeString","colorMapReverse","getUCoordinateByIndex","getDCoordinateByIndex","getFCoordinateByIndex","getBCoordinateByIndex","getLCoordinateByIndex","getRCoordinateByIndex","findCubieByPosition","find","offset","faceChars","slice","letter","colorString","xyz","handleFindSolution","symmetryRes","fetch","method","headers","JSON","stringify","cube_data","symmetryData","json","found","console","log","state","solveRes","solveData","solution","err","error","handleGuideMe","showManualStep","index","showSuccessMessage","showArrowsOnLayer","removeArrowsFromLayer","nextIndex","faceElements","querySelectorAll","arrow","createElement","classList","add","innerHTML","appendChild","querySelector","remove","messageBox","innerText","renderCubies","cx","cy","cz","className","width","height","transform","transformStyle","children","Object","entries","border","backgroundColor","getFaceTransform","fileName","_jsxFileName","lineNumber","columnNumber","onClick","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","_c","$RefreshReg$"],"sources":["/home/gal98/projects/pocket-cube-solver/frontend/src/components/Cube.js"],"sourcesContent":["/* eslint-disable default-case */\nimport React, { useState, useEffect } from \"react\";\nimport \"./Cube.css\";\nimport API_BASE_URL from \"../config\";\n\n// const defaultColors = {\n//   U: \"blue\",   // Up\n//   D: \"green\",  // Down\n//   F: \"orange\", // Front\n//   B: \"red\",    // Back\n//   L: \"white\",  // Left\n//   R: \"yellow\", // Right\n// };\n\n\nconst initialCubeState = [\n  {\n    id: \"UBL\",\n    position: [-1, 1, -1],\n    colors: { U: \"blue\", B: \"red\", L: \"yellow\" },\n  },\n  {\n    id: \"UBR\",\n    position: [1, 1, -1],\n    colors: { U: \"blue\", B: \"red\", R: \"white\" },\n  },\n  {\n    id: \"UFL\",\n    position: [-1, 1, 1],\n    colors: { U: \"blue\", F: \"orange\", L: \"yellow\" },\n  },\n  {\n    id: \"UFR\",\n    position: [1, 1, 1],\n    colors: { U: \"blue\", F: \"orange\", R: \"white\" },\n  },\n  {\n    id: \"DBL\",\n    position: [-1, -1, -1],\n    colors: { D: \"green\", B: \"red\", L: \"yellow\" },\n  },\n  {\n    id: \"DBR\",\n    position: [1, -1, -1],\n    colors: { D: \"green\", B: \"red\", R: \"white\" },\n  },\n  {\n    id: \"DFL\",\n    position: [-1, -1, 1],\n    colors: { D: \"green\", F: \"orange\", L: \"yellow\" },\n  },\n  {\n    id: \"DFR\",\n    position: [1, -1, 1],\n    colors: { D: \"green\", F: \"orange\", R: \"white\" },\n  },\n];\n\n\n// Helper that decides exactly which layer to rotate, given the face clicked\n// and the (x,y,z) position of that cubie.\nfunction getLayerFromFaceAndPosition(face, x, y, z) {\n  // Convert to integers, since dataset attributes come as strings\n  x = parseInt(x, 10);\n  y = parseInt(y, 10);\n  z = parseInt(z, 10);\n\n  switch (face) {\n    case \"U\":\n      // Only rotate top layer if y=1\n      return y === 1 ? \"U\" : null;\n\n    case \"D\":\n      // Only rotate bottom layer if y=-1\n      return y === -1 ? \"D\" : null;\n\n    case \"F\":\n      // Only rotate front layer if z=1\n      return z === 1 ? \"F\" : null;\n\n    case \"B\":\n      // Only rotate back layer if z=-1\n      return z === -1 ? \"B\" : null;\n\n    case \"R\":\n      // Only rotate right layer if x=1\n      return x === 1 ? \"R\" : null;\n\n    case \"L\":\n      // Only rotate left layer if x=-1\n      return x === -1 ? \"L\" : null;\n\n    default:\n      return null;\n  }\n}\n\nconst Cube = () => {\n  const [cubeState, setCubeState] = useState(initialCubeState);\n  const [shouldSolve, setShouldSolve] = useState(false);\n  const [rotation, setRotation] = useState({ x: -30, y: 45 }); // Whole-cube rotation\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const [selectedLayer, setSelectedLayer] = useState(null);\n  const [solutionSteps, setSolutionSteps] = useState([]);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [guideMode, setGuideMode] = useState(false);\n  \n\n  // --- MOUSE EVENTS ---\n  const handleMouseDown = (event) => {\n    // 1) Check if you clicked on a specific face via data-face\n    const faceElement = event.target.closest(\".cubie-face\");\n    if (faceElement) {\n      const face = faceElement.dataset.face; // e.g., \"U\", \"R\", ...\n      if (face) {\n        // Grab the parent .cubie to read its data-x, data-y, data-z\n        const cubieEl = faceElement.closest(\".cubie\");\n        if (cubieEl) {\n          const { x, y, z } = cubieEl.dataset;\n          // Figure out the *actual* layer to rotate, if any\n          const layer = getLayerFromFaceAndPosition(face, x, y, z);\n\n          if (layer) {\n            setSelectedLayer(layer);\n            setDragStart({ x: event.clientX, y: event.clientY });\n            \n            return; // Skip rotating the whole cube\n          }\n        }\n      }\n    }\n\n    // 2) Otherwise, rotate the entire cube\n    setIsDragging(true);\n    setDragStart({ x: event.clientX, y: event.clientY });\n    document.body.style.cursor = \"grabbing\";\n  };\n\n  const handleMouseMove = (event) => {\n    // A) If dragging the whole cube\n    const MAX_ROTATION_X = 90;  // Maximum x rotation\n    const MIN_ROTATION_X = -90; // Minimum x rotation\n    \n    if (isDragging) {\n      const deltaX = event.clientX - dragStart.x;\n      const deltaY = event.clientY - dragStart.y;\n    \n      // Update x with the deltaY, but clamp it between MIN_ROTATION_X and MAX_ROTATION_X\n      setRotation((prev) => {\n        const newX = prev.x - deltaY * 0.3;\n        const newY = prev.y + deltaX * 0.3;\n    \n        return {\n          x: Math.max(MIN_ROTATION_X, Math.min(newX, MAX_ROTATION_X)), // Clamp x\n          y: newY,\n        };\n      });\n    \n      setDragStart({ x: event.clientX, y: event.clientY });\n    }\n    \n    if (!guideMode) {\n      // B) If dragging a face to rotate that layer\n      if (selectedLayer) {\n        const deltaX = event.clientX - dragStart.x;\n        if (Math.abs(deltaX) > 30) {\n          const direction = deltaX > 0 ? 90 : -90;\n          rotateLayerCubies(selectedLayer, direction);\n          setSelectedLayer(null); // Prevent repeated rotations on same drag\n        }\n      }\n    } else {\n      const expectedLayer = solutionSteps[currentStepIndex]; \n      if (selectedLayer === expectedLayer) {\n        const deltaX = event.clientX - dragStart.x;\n        const direction = deltaX > 0 ? 90 : -90;\n        let validRotate = false;\n\n        if ((selectedLayer === \"U\" || selectedLayer === \"F\" || selectedLayer === \"R\" || selectedLayer === \"D\") && direction === 90) {\n          validRotate = true;\n        }\n\n        if ((selectedLayer === \"B\" || selectedLayer === \"L\") && direction === -90) {\n          validRotate = true;\n        }\n      \n        if (Math.abs(deltaX) > 30 && validRotate) {\n          //const direction = deltaX > 0 ? 90 : -90;\n          rotateLayerCubies(selectedLayer, direction);\n          setSelectedLayer(null); // Prevent repeated rotations on same drag\n          handleUserRotationDone();\n          validRotate = false;\n        }\n      }\n    }\n  };\n\n\n      // // Determine arrow direction\n      // let direction = 90;\n      // if (layer === \"B\" || layer === \"L\") {\n      //   direction = -90;\n      // }\n    \n\n  const handleMouseUp = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n\n  const handleMouseLeave = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n\n  const rotateLayerCubies = (layer, direction) => {\n    setCubeState((prevState) => {\n      const newState = [...prevState];\n      let axisIndex, axisValue;\n      switch (layer) {\n        case \"U\":\n          axisIndex = 1; // y\n          axisValue = 1;\n          break;\n        case \"D\":\n          axisIndex = 1;\n          axisValue = -1;\n          break;\n        case \"F\":\n          axisIndex = 2; // z\n          axisValue = 1;\n          break;\n        case \"B\":\n          axisIndex = 2;\n          axisValue = -1;\n          break;\n        case \"R\":\n          axisIndex = 0; // x\n          axisValue = 1;\n          break;\n        case \"L\":\n          axisIndex = 0;\n          axisValue = -1;\n          break;\n        default:\n          return newState;\n      }\n      const affectedCubies = newState.filter(\n        (c) => c.position[axisIndex] === axisValue\n      );\n  \n      // // Helper to update a sticker only if it exists.\n      // const updateColor = (colors, target, value) => {\n      //   return colors.hasOwnProperty(target) ? value : undefined;\n      // };\n  \n      const rotateCubie = (cubie) => {\n        const { position, colors } = cubie;\n        const [x, y, z] = position;\n        let newPosition = [...position];\n        let newColors = { ...colors };\n      \n        // Helper function: assign oldFace to newFace if oldFace existed, then delete oldFace\n        const reassignFace = (oldFace, newFace) => {\n          if (colors[oldFace]) {\n            newColors[newFace] = colors[oldFace];\n            //delete newColors[oldFace];\n          }\n        };\n      \n        switch (layer) {\n          case \"U\":\n            if (direction > 0) {\n              // +90 around U\n              newPosition = [z, y, -x];\n              // Keep U face\n              if (colors.U) newColors.U = colors.U;\n      \n              //F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"R\", \"B\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"L\", \"F\");\n            } else {\n              // -90 around U\n              newPosition = [-z, y, x];\n              if (colors.U) newColors.U = colors.U;\n      \n              // F->L, L->B, B->R, R->F (the reverse mapping)\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"L\", \"B\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"R\", \"F\");\n            }\n            break;\n      \n          case \"D\":\n            if (direction > 0) {\n              newPosition = [z, y, -x];\n              if (colors.D) newColors.D = colors.D;\n      \n              // F->L, L->B, B->R, R->F (for example)\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"L\", \"F\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"R\", \"B\");\n\n\n\n            } else {\n              newPosition = [-z, y, x];\n              if (colors.D) newColors.D = colors.D;\n      \n              // F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"R\", \"F\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"L\", \"B\");\n            }\n            break;\n      \n          case \"F\":\n            if (direction > 0) {\n              newPosition = [y, -x, z];\n              if (colors.F) newColors.F = colors.F;\n      \n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            } else {\n              newPosition = [-y, x, z];\n              if (colors.F) newColors.F = colors.F;\n      \n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            }\n            break;\n      \n          case \"B\":\n            if (direction > 0) {\n              newPosition = [-y, x, z];\n              if (colors.B) newColors.B = colors.B;\n      \n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            } else {\n              newPosition = [y, -x, z];\n              if (colors.B) newColors.B = colors.B;\n      \n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            }\n            break;\n      \n          case \"R\":\n            if (direction > 0) {\n              newPosition = [x, z, -y];\n              if (colors.R) newColors.R = colors.R;\n      \n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            } else {\n              newPosition = [x, -z, y];\n              if (colors.R) newColors.R = colors.R;\n      \n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            }\n            break;\n      \n          case \"L\":\n            if (direction > 0) {\n              newPosition = [x, -z, y];\n              if (colors.L) newColors.L = colors.L;\n      \n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            } else {\n              newPosition = [x, z, -y];\n              if (colors.L) newColors.L = colors.L;\n      \n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            }\n            break;\n        }\n      \n        return { ...cubie, position: newPosition, colors: newColors };\n      };\n      \n  \n      const updated = {};\n      affectedCubies.forEach((cubie) => {\n        updated[cubie.id] = rotateCubie(cubie);\n      });\n  \n      return newState.map((c) => updated[c.id] || c);\n    });\n  };\n  \n  const scrambleCube = async () => {\n    // Decide how many random moves you want:\n    const SCRAMBLE_LENGTH = 15; // or 20, etc.\n\n    const faces = [\"U\", \"D\", \"L\", \"R\", \"F\", \"B\"];\n    const directions = [90, -90]; // clockwise or counterclockwise\n\n    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms)); // Delay function\n\n    for (let i = 0; i < SCRAMBLE_LENGTH; i++) {\n      const randomFace = faces[Math.floor(Math.random() * faces.length)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      \n      // rotateLayerCubies is your existing method to do 90° turns\n      rotateLayerCubies(randomFace, randomDir);\n\n      // Wait for a timeout before the next move (e.g., 300ms between moves)\n      await delay(300); \n    }\n  };\n\n  const flattenCubeStateByPosition = (cubeState) => {\n    // Convert color strings to single-letter codes\n    const getColorLetter = (color) => {\n      const colorMap = {\n        white: \"W\",\n        yellow: \"Y\",\n        blue: \"B\",\n        green: \"G\",\n        red: \"R\",\n        orange: \"O\",\n      };\n      return colorMap[color] || \"?\";\n    };\n\n    // ========== U FACE ========== \n    // y === 1, have a U sticker\n    const getUIndex = (cubie) => {\n      const [x, _, z] = cubie.position;\n      // Example: top-left => 0, top-right => 1, bottom-left => 2, bottom-right => 3\n      // Fill in the coordinates that physically match each slot.\n      // (Just like your existing getUIndex)\n      if (x ===  1 && z === -1) return 2;  \n      if (x === -1 && z === -1) return 3;\n      if (x ===  1 && z ===  1) return 0;\n      if (x === -1 && z ===  1) return 1;\n      return 99; \n    };\n\n    // ========== D FACE ========== \n    // y === -1, have a D sticker\n    const getDIndex = (cubie) => {\n      const [x, _, z] = cubie.position;\n      // TODO: Decide how you'd like to label D's top-left => 0, top-right => 1, etc.\n      // For instance:\n      // if (x=-1,z=-1) => 0, (x=1,z=-1) => 1, (x=-1,z=1) => 2, (x=1,z=1) => 3\n      // or any arrangement that yields the correct “visual” order for D.\n      if (x === -1 && z === -1) return 2;\n      if (x ===  1 && z === -1) return 3;\n      if (x === -1 && z ===  1) return 0;\n      if (x ===  1 && z ===  1) return 1;\n      return 99;\n    };\n\n    // ========== F FACE ==========\n    const getFIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // y is your vertical axis, x is left-right, z=1 for front\n      // Decide which coordinate combos map to top-left => 0, top-right => 1, etc.\n      // Example:\n      // if (y=1, x=-1) => 0, (y=1, x=1) => 1, (y=-1, x=-1) => 2, (y=-1, x=1) => 3\n      // So you end up with top row = y=1, bottom row = y=-1, left col = x=-1, right col = x=1\n      if (y ===  1 && x === -1) return 0;\n      if (y ===  1 && x ===  1) return 1;\n      if (y === -1 && x === -1) return 2;\n      if (y === -1 && x ===  1) return 3;\n      return 99;\n    };\n\n    // ========== B FACE ==========\n    const getBIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // Similar logic for the back face (z=-1).\n      // If you want top-left => y=1,x=1 => 0, etc., fill it in:\n      if (y ===  1 && x ===  1) return 0;\n      if (y ===  1 && x === -1) return 1;\n      if (y === -1 && x ===  1) return 2;\n      if (y === -1 && x === -1) return 3;\n      return 99;\n    };\n\n    // ========== L FACE ==========\n    const getLIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // x = -1 for left\n      // Decide top-left => (?), top-right => (?), bottom-left => (?), etc.\n      // Possibly y=1 => top, z=-1 => left, etc.\n      if (y === 1 && z === 1) return 1;\n      if (y === 1 && z === -1) return 0;\n      if (y === -1 && z === 1) return 3;\n      if (y === -1 && z === -1) return 2;\n      return 99;\n    };\n\n    // ========== R FACE ==========\n    const getRIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // x=+1 for right\n      // Fill in your top-left -> index0, top-right -> index1, etc.\n      if (y ===  1 && z === -1) return 1;\n      if (y ===  1 && z ===  1)  return 0;\n      if (y === -1 && z === -1) return 3;\n      if (y === -1 && z ===  1) return 2;\n      return 99;\n    };\n\n    // The main function to get stickers for each face:\n    const getFaceStickers = (face) => {\n      let filtered = [];\n      switch (face) {\n        case \"U\": {\n          filtered = cubeState.filter(c => c.position[1] === 1 && c.colors.U);\n          filtered.sort((a, b) => getUIndex(a) - getUIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.U)).join(\"\");\n        }\n        case \"D\": {\n          filtered = cubeState.filter(c => c.position[1] === -1 && c.colors.D);\n          filtered.sort((a, b) => getDIndex(a) - getDIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.D)).join(\"\");\n        }\n        case \"F\": {\n          filtered = cubeState.filter(c => c.position[2] === 1 && c.colors.F);\n          filtered.sort((a, b) => getFIndex(a) - getFIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.F)).join(\"\");\n        }\n        case \"B\": {\n          filtered = cubeState.filter(c => c.position[2] === -1 && c.colors.B);\n          filtered.sort((a, b) => getBIndex(a) - getBIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.B)).join(\"\");\n        }\n        case \"L\": {\n          filtered = cubeState.filter(c => c.position[0] === -1 && c.colors.L);\n          filtered.sort((a, b) => getLIndex(a) - getLIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.L)).join(\"\");\n        }\n        case \"R\": {\n          filtered = cubeState.filter(c => c.position[0] === 1 && c.colors.R);\n          filtered.sort((a, b) => getRIndex(a) - getRIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.R)).join(\"\");\n        }\n        default:\n          return \"\";\n      }\n    };\n\n    // Flatten in the face order your solver expects\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    return faceOrder.map(face => getFaceStickers(face)).join(\"\");\n  };\n\n\n\n\n  // const checkSymmetryAndSolve = async () => {\n  //   // 1) Flatten the user’s current cube state\n  //   console.log(\"Cube state original format - Before update:\" , cubeState);\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   console.log(\"Flattened Cube String:\", cubeString);\n\n  //   try {\n  //     // 2) Call your /find_symmetry endpoint first\n  //     const res = await fetch(`${API_BASE_URL}/find_symmetry`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await res.json();\n      \n  //     if (!data.found) {\n  //       console.log(\"No matching or symmetrical version found. Cannot solve.\");\n  //       return; // or show a UI error\n  //     }\n      \n  //     // If found == true\n  //     if (data.state !== cubeString) {\n  //       // Means we have a symmetrical match that differs from the user's state\n  //       console.log(\"Server suggests symmetrical reorientation:\", data.state);\n  //       // 3) Reorient the cube to that symmetrical version\n  //       reorientCubeFromString(data.state);\n  //     }\n\n  //     else {\n  //       // If no reorientation is needed, we can still trigger the solver:\n  //       setShouldSolve(true);\n  //     }\n\n      \n  //   } catch (err) {\n  //     console.error(\"Error checking symmetry:\", err);\n  //   }\n  // }\n\n  //   // useEffect to call solver after state is updated\n  // useEffect(() => {\n  //   if (shouldSolve) {\n  //     callSolveEndpoint(); // uses the *latest* cubeState\n  //     setShouldSolve(false);\n  //   }\n  // }, [cubeState, shouldSolve]);\n  \n  // Example: callSolveEndpoint references your existing handleSolve logic\n  // const callSolveEndpoint = async () => {\n  //   console.log(\"Cube state original format - after update:\" , cubeState);\n\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   //const finalString = flattenCubeStateByPosition(cubeState);\n  //   // the existing logic from handleSolve\n  //   console.log(\"Cube state string - after upadate: \", cubeString);\n\n  //   try {\n  //     const response = await fetch(`${API_BASE_URL}/solve`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await response.json();\n  //     if (!data) {\n  //       console.log(\"no matching solution found\");\n  //       return;\n  //     }\n  //     guideUserThroughSolution(data.solution);\n  //   } catch (error) {\n  //     console.error(\"Error solving:\", error);\n  //   }\n  // };\n  \n  \n  function createBlankCubeState() {\n    return [\n      {\n        id: \"UBL\",\n        position: [-1, 1, -1],\n        colors: {},\n      },\n      {\n        id: \"UBR\",\n        position: [1, 1, -1],\n        colors: {},\n      },\n      {\n        id: \"UFL\",\n        position: [-1, 1, 1],\n        colors: {},\n      },\n      {\n        id: \"UFR\",\n        position: [1, 1, 1],\n        colors: {},\n      },\n      {\n        id: \"DBL\",\n        position: [-1, -1, -1],\n        colors: {},\n      },\n      {\n        id: \"DBR\",\n        position: [1, -1, -1],\n        colors: {},\n      },\n      {\n        id: \"DFL\",\n        position: [-1, -1, 1],\n        colors: {},\n      },\n      {\n        id: \"DFR\",\n        position: [1, -1, 1],\n        colors: {},\n      },\n    ];\n  }\n  \n\n  function reorientCubeFromString(cubeString) {\n  // We'll parse 24 characters in blocks of 4 for U,D,F,B,R,L\n  // For each block, we figure out which cubies get which face color\n\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    // A helper to convert a single letter like 'B' or 'O' back to e.g. \"blue\" or \"orange\"\n    const colorMapReverse = {\n      \"W\": \"white\",\n      \"Y\": \"yellow\",\n      \"B\": \"blue\",\n      \"G\": \"green\",\n      \"R\": \"red\",\n      \"O\": \"orange\",\n    };\n\n    // 1) Create a blank 8-cubie array\n    let newState = createBlankCubeState();\n\n    // 2) Define the “index → coordinate” for each face\n    const getUCoordinateByIndex = (i) => {\n      // Inverse of your getUIndex. \n      switch(i) {\n        case 2: return [1, 1, -1];   // x=1,z=-1\n        case 3: return [-1,1, -1];  // x=-1,z=-1\n        case 0: return [1, 1, 1];    // x=1,z=1\n        case 1: return [-1,1, 1];    // x=-1,z=1\n        default:\n          return \" \"\n      }\n    };\n\n    const getDCoordinateByIndex = (i) => {\n      switch(i) {\n        case 2: return [-1,-1,-1];\n        case 3: return [1, -1, -1];\n        case 0: return [-1,-1, 1];\n        case 1: return [1, -1, 1];\n        default:\n          return \" \"\n      }\n    };\n\n    const getFCoordinateByIndex = (i) => {\n      switch(i) {\n        case 0: return [-1,1,1];\n        case 1: return [1, 1,1];\n        case 2: return [-1,-1,1];\n        case 3: return [1, -1,1];\n        default:\n          return \" \"\n      }\n    };\n\n    \n    const getBCoordinateByIndex = (i) => {\n      switch(i) {\n        case 0: return [1,1,-1];\n        case 1: return [-1, 1,-1];\n        case 2: return [1,-1,-1];\n        case 3: return [-1, -1,-1];\n        default:\n          return \" \"\n      }\n    };\n\n    const getLCoordinateByIndex = (i) => {\n      switch(i) {\n        case 1: return [-1,1,1];\n        case 0: return [-1, 1,-1];\n        case 3: return [-1,-1,1];\n        case 2: return [-1, -1,-1];\n        default:\n          return \" \"\n      }\n    };\n\n    \n    const getRCoordinateByIndex = (i) => {\n      switch(i) {\n        case 1: return [1,1,-1];\n        case 0: return [1, 1,1];\n        case 3: return [1,-1,-1];\n        case 2: return [1, -1,1];\n        default:\n          return \" \"\n      }\n    };\n    // Similarly define getFCoordinateByIndex, getBCoordinateByIndex, etc...\n    // matching how you set up getFIndex, getBIndex, etc.\n\n    // 3) A helper that finds the cubie in newState that matches a coordinate\n    function findCubieByPosition(x, y, z) {\n      return newState.find(c => \n        c.position[0] === x &&\n        c.position[1] === y &&\n        c.position[2] === z\n      );\n    }\n\n    // 4) Parse the cubeString in 6 chunks of 4\n    let offset = 0;\n    for (let face of faceOrder) {\n      const faceChars = cubeString.slice(offset, offset+4); // next 4 letters\n      offset += 4;\n\n      for (let i = 0; i < 4; i++) {\n        const letter = faceChars[i];  // e.g. 'B', 'O', 'W'\n        const colorString = colorMapReverse[letter] || \"unknown\";\n\n        let xyz;\n        if (face === \"U\") {\n          xyz = getUCoordinateByIndex(i);\n        } else if (face === \"D\") {\n          xyz = getDCoordinateByIndex(i);\n        } \n        else if (face === \"F\") { xyz = getFCoordinateByIndex(i); }\n        else if (face === \"B\") { xyz = getBCoordinateByIndex(i); }\n        else if (face === \"R\") { xyz = getRCoordinateByIndex(i); }\n        else if (face === \"L\") { xyz = getLCoordinateByIndex(i); }\n\n        const [x,y,z] = xyz;\n        // find the matching cubie\n        const cubie = findCubieByPosition(x,y,z);\n        if (cubie) {\n          cubie.colors[face] = colorString;\n        }\n      }\n    }\n    // fill in newState\n    setCubeState(newState);\n\n    // Also set a flag\n    //setShouldSolve(true);\n  }\n\n  \n    // 1) \"Find Solution\" button\n    const handleFindSolution = async () => {\n      const cubeString = flattenCubeStateByPosition(cubeState);\n  \n      try {\n        // Check for symmetry\n        const symmetryRes = await fetch(`${API_BASE_URL}/find_symmetry`, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ cube_data: cubeString }),\n        });\n        const symmetryData = await symmetryRes.json();\n  \n        if (!symmetryData.found) {\n          console.log(\"No symmetrical version found. Can't solve.\");\n          setSolutionSteps(null);\n          return;\n        }\n  \n        // If we got a symmetrical match, reorient the cube\n        if (symmetryData.state !== cubeString) {\n          reorientCubeFromString(symmetryData.state);\n          console.log(\"notice: cube switch to identical symmetic state - adapt your cube with this symmetrica state\")\n        }\n  \n        // Now request the solution steps from /solve\n        const solveRes = await fetch(`${API_BASE_URL}/solve`, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ cube_data: symmetryData.state }),\n        });\n        const solveData = await solveRes.json();\n  \n  \n        if (solveData.solution[0] === \"Congratulations!\") {\n          console.log(\"Cube is already in its solved state\");\n          setSolutionSteps(null);\n          return;\n        }\n\n        setSolutionSteps(solveData.solution);\n\n        console.log(\"Solution steps are ready. Click 'Guide Me' to start solving.\");\n      } catch (err) {\n        console.error(\"Error finding or solving:\", err);\n      }\n    };\n  \n    // 2) \"Guide Me\" button\n    const handleGuideMe = () => {\n      if (!solutionSteps || solutionSteps.length === 0) {\n        console.log(\"No solution steps. Click 'Find Solution' first.\");\n        return;\n      }\n      // Start from the first move\n      setGuideMode(true);\n      setCurrentStepIndex(0);\n      showManualStep(0);\n    };\n    \n\n\n  // const guideUserThroughSolution = async (solutionMoves) => {\n  //   for (const layer of solutionMoves) {\n\n  //     if (layer === \"Congratulations!\") {\n  //       console.log(\"Done!\");\n  //       return;\n  //     }\n\n  //     let direction = 90;\n  //     if (layer === \"B\" || layer === \"L\") {\n  //       direction = -90;\n  //     }\n  //     // Show guidance with an arrow\n  //     showArrowOnFace(layer, direction);\n  \n  //     // Wait before animating the move\n  //     await delay(1000);  // 1-second pause before executing the move\n  \n  //     // Perform the rotation (animate and update state)\n  //     rotateLayerCubies(layer, direction);\n  \n  //     // Remove the arrow after the move\n  //     removeArrowFromFace(layer);\n  \n  //     // Wait before moving to the next step\n  //     await delay(1000);\n  //   }\n  \n  //   // Final success message\n  //   showSuccessMessage();\n  // };\n  \n\n  const showManualStep = (index) => {\n    // If we’re beyond the last move, show success\n    if (index >= solutionSteps.length) {\n      showSuccessMessage();\n      return;\n    }\n  \n    const layer = solutionSteps[index];\n    // If it's some special marker like \"Congratulations!\"\n    if (layer === \"Congratulations!\") {\n      showSuccessMessage();\n      setGuideMode(false);\n      return;\n    }\n  \n    // Determine arrow direction\n    let direction = 90;\n    if (layer === \"B\" || layer === \"L\") {\n      direction = -90;\n    }\n  \n    // Display the arrow on the correct face\n    showArrowsOnLayer(layer, direction);\n  \n    // Now we wait for the user to rotate manually...\n    // The user will click \"Next\" or some UI button once they’ve done the move\n  };\n\n  const handleUserRotationDone = () => {\n    // Remove the arrow from the current face\n    const layer = solutionSteps[currentStepIndex];\n    removeArrowsFromLayer(layer);\n  \n    // Move on to the next step\n    const nextIndex = currentStepIndex + 1;\n    setCurrentStepIndex(nextIndex);\n    showManualStep(nextIndex);\n  };\n  \n  \n\n  const showArrowsOnLayer = (layer, direction) => {\n    setTimeout(() => {\n      // Grab all .cubie-face elements whose data-face matches\n      const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n  \n      faceElements.forEach((face) => {\n        // Create the arrow element\n        const arrow = document.createElement(\"div\");\n        arrow.classList.add(\"rotation-arrow\");\n  \n        if (layer === \"U\") {\n          arrow.innerHTML = direction < 0 ? \"↻\" : \"↺\";\n        } else {\n          arrow.innerHTML = direction > 0 ? \"↻\" : \"↺\";\n        }\n  \n        // Append the arrow to the face\n        face.appendChild(arrow);\n      });\n    }, 200); // Delay of 200ms; adjust as needed\n  };\n  \n\n\n  \n\n  // Remove arrows from every face in that layer\n  const removeArrowsFromLayer = (layer) => {\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n\n    faceElements.forEach((face) => {\n      const arrow = face.querySelector(\".rotation-arrow\");\n      if (arrow) arrow.remove();\n    });\n  };\n\n\n  const showSuccessMessage = () => {\n    const messageBox = document.createElement(\"div\");\n    messageBox.classList.add(\"success-message\");\n    messageBox.innerText = \"🎉 Cube Solved!\";\n    document.body.appendChild(messageBox);\n  \n    setTimeout(() => {\n      messageBox.remove(); // Remove after 3 seconds\n    }, 3000);\n  };\n  \n\n  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n\n  // --- RENDERING ---\n  const renderCubies = () =>\n    cubeState.map((cubie) => {\n      const { id, position, colors } = cubie;\n      const [cx, cy, cz] = position;\n\n      return (\n        <div\n          key={id}\n          className=\"cubie\"\n          data-x={cx}     // So we can read them on click\n          data-y={cy}\n          data-z={cz}\n          style={{\n            position: \"absolute\",\n            width: \"88px\",\n            height: \"88px\",\n            transform: `translate3d(${cx * 45}px, ${-cy * 45}px, ${cz * 45}px)`,\n            transformStyle: \"preserve-3d\",\n          }}\n        >\n          {Object.entries(colors).map(([face, color]) => (\n            <div\n              key={face}\n              className=\"cubie-face\"\n              data-face={face} // e.g., \"U\", \"D\", \"F\", etc.\n              style={{\n                position: \"absolute\",\n                width: \"80px\",\n                height: \"80px\",\n                border: \"8px solid black\",\n                backgroundColor: color,\n                transform: getFaceTransform(face),\n                cursor: \"pointer\",\n              }}\n            />\n          ))}\n        </div>\n      );\n    });\n\n  // Places each face in the correct orientation\n  const getFaceTransform = (face) => {\n    switch (face) {\n      case \"U\":\n        return \"rotateX(90deg) translateZ(45px)\";\n      case \"D\":\n        return \"rotateX(-90deg) translateZ(45px)\";\n      case \"F\":\n        return \"translateZ(45px)\";\n      case \"B\":\n        return \"rotateY(180deg) translateZ(45px)\";\n      case \"L\":\n        return \"rotateY(-90deg) translateZ(45px)\";\n      case \"R\":\n        return \"rotateY(90deg) translateZ(45px)\";\n      default:\n        return \"\";\n    }\n  };\n\n\n\n  return (\n    <div>\n      <div className=\"button-container\">\n        <button className=\"scramble\" onClick={scrambleCube}>Scramble</button>\n        <button className=\"find-solution\" onClick={handleFindSolution}>Find Solution</button>\n        <button className=\"guide-me\" onClick={handleGuideMe}>Guide Me</button>\n      </div>\n      <div\n        className=\"cube-container\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseLeave}\n      >\n        <div\n          className=\"cube\"\n          style={{\n            transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`,\n          }}\n        >\n          {renderCubies()}\n        </div>\n      </div>\n    </div>\n  );\n  \n};\n\nexport default Cube;  // Export the Cube component\n"],"mappings":";;AAAA;AACA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,OAAO,YAAY;AACnB,OAAOC,YAAY,MAAM,WAAW;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAGA,MAAMC,gBAAgB,GAAG,CACvB;EACEC,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACrBC,MAAM,EAAE;IAAEC,CAAC,EAAE,MAAM;IAAEC,CAAC,EAAE,KAAK;IAAEC,CAAC,EAAE;EAAS;AAC7C,CAAC,EACD;EACEL,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACpBC,MAAM,EAAE;IAAEC,CAAC,EAAE,MAAM;IAAEC,CAAC,EAAE,KAAK;IAAEE,CAAC,EAAE;EAAQ;AAC5C,CAAC,EACD;EACEN,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACpBC,MAAM,EAAE;IAAEC,CAAC,EAAE,MAAM;IAAEI,CAAC,EAAE,QAAQ;IAAEF,CAAC,EAAE;EAAS;AAChD,CAAC,EACD;EACEL,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACnBC,MAAM,EAAE;IAAEC,CAAC,EAAE,MAAM;IAAEI,CAAC,EAAE,QAAQ;IAAED,CAAC,EAAE;EAAQ;AAC/C,CAAC,EACD;EACEN,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACtBC,MAAM,EAAE;IAAEM,CAAC,EAAE,OAAO;IAAEJ,CAAC,EAAE,KAAK;IAAEC,CAAC,EAAE;EAAS;AAC9C,CAAC,EACD;EACEL,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACrBC,MAAM,EAAE;IAAEM,CAAC,EAAE,OAAO;IAAEJ,CAAC,EAAE,KAAK;IAAEE,CAAC,EAAE;EAAQ;AAC7C,CAAC,EACD;EACEN,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACrBC,MAAM,EAAE;IAAEM,CAAC,EAAE,OAAO;IAAED,CAAC,EAAE,QAAQ;IAAEF,CAAC,EAAE;EAAS;AACjD,CAAC,EACD;EACEL,EAAE,EAAE,KAAK;EACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;EACpBC,MAAM,EAAE;IAAEM,CAAC,EAAE,OAAO;IAAED,CAAC,EAAE,QAAQ;IAAED,CAAC,EAAE;EAAQ;AAChD,CAAC,CACF;;AAGD;AACA;AACA,SAASG,2BAA2BA,CAACC,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAClD;EACAF,CAAC,GAAGG,QAAQ,CAACH,CAAC,EAAE,EAAE,CAAC;EACnBC,CAAC,GAAGE,QAAQ,CAACF,CAAC,EAAE,EAAE,CAAC;EACnBC,CAAC,GAAGC,QAAQ,CAACD,CAAC,EAAE,EAAE,CAAC;EAEnB,QAAQH,IAAI;IACV,KAAK,GAAG;MACN;MACA,OAAOE,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI;IAE7B,KAAK,GAAG;MACN;MACA,OAAOA,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI;IAE9B,KAAK,GAAG;MACN;MACA,OAAOC,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI;IAE7B,KAAK,GAAG;MACN;MACA,OAAOA,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI;IAE9B,KAAK,GAAG;MACN;MACA,OAAOF,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI;IAE7B,KAAK,GAAG;MACN;MACA,OAAOA,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,GAAG,IAAI;IAE9B;MACE,OAAO,IAAI;EACf;AACF;AAEA,MAAMI,IAAI,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACjB,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGxB,QAAQ,CAACK,gBAAgB,CAAC;EAC5D,MAAM,CAACoB,WAAW,EAAEC,cAAc,CAAC,GAAG1B,QAAQ,CAAC,KAAK,CAAC;EACrD,MAAM,CAAC2B,QAAQ,EAAEC,WAAW,CAAC,GAAG5B,QAAQ,CAAC;IAAEiB,CAAC,EAAE,CAAC,EAAE;IAAEC,CAAC,EAAE;EAAG,CAAC,CAAC,CAAC,CAAC;EAC7D,MAAM,CAACW,UAAU,EAAEC,aAAa,CAAC,GAAG9B,QAAQ,CAAC,KAAK,CAAC;EACnD,MAAM,CAAC+B,SAAS,EAAEC,YAAY,CAAC,GAAGhC,QAAQ,CAAC;IAAEiB,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,CAAC;EAC1D,MAAM,CAACe,aAAa,EAAEC,gBAAgB,CAAC,GAAGlC,QAAQ,CAAC,IAAI,CAAC;EACxD,MAAM,CAACmC,aAAa,EAAEC,gBAAgB,CAAC,GAAGpC,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAACqC,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGtC,QAAQ,CAAC,CAAC,CAAC;EAC3D,MAAM,CAACuC,SAAS,EAAEC,YAAY,CAAC,GAAGxC,QAAQ,CAAC,KAAK,CAAC;;EAGjD;EACA,MAAMyC,eAAe,GAAIC,KAAK,IAAK;IACjC;IACA,MAAMC,WAAW,GAAGD,KAAK,CAACE,MAAM,CAACC,OAAO,CAAC,aAAa,CAAC;IACvD,IAAIF,WAAW,EAAE;MACf,MAAM3B,IAAI,GAAG2B,WAAW,CAACG,OAAO,CAAC9B,IAAI,CAAC,CAAC;MACvC,IAAIA,IAAI,EAAE;QACR;QACA,MAAM+B,OAAO,GAAGJ,WAAW,CAACE,OAAO,CAAC,QAAQ,CAAC;QAC7C,IAAIE,OAAO,EAAE;UACX,MAAM;YAAE9B,CAAC;YAAEC,CAAC;YAAEC;UAAE,CAAC,GAAG4B,OAAO,CAACD,OAAO;UACnC;UACA,MAAME,KAAK,GAAGjC,2BAA2B,CAACC,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC;UAExD,IAAI6B,KAAK,EAAE;YACTd,gBAAgB,CAACc,KAAK,CAAC;YACvBhB,YAAY,CAAC;cAAEf,CAAC,EAAEyB,KAAK,CAACO,OAAO;cAAE/B,CAAC,EAAEwB,KAAK,CAACQ;YAAQ,CAAC,CAAC;YAEpD,OAAO,CAAC;UACV;QACF;MACF;IACF;;IAEA;IACApB,aAAa,CAAC,IAAI,CAAC;IACnBE,YAAY,CAAC;MAAEf,CAAC,EAAEyB,KAAK,CAACO,OAAO;MAAE/B,CAAC,EAAEwB,KAAK,CAACQ;IAAQ,CAAC,CAAC;IACpDC,QAAQ,CAACC,IAAI,CAACC,KAAK,CAACC,MAAM,GAAG,UAAU;EACzC,CAAC;EAED,MAAMC,eAAe,GAAIb,KAAK,IAAK;IACjC;IACA,MAAMc,cAAc,GAAG,EAAE,CAAC,CAAE;IAC5B,MAAMC,cAAc,GAAG,CAAC,EAAE,CAAC,CAAC;;IAE5B,IAAI5B,UAAU,EAAE;MACd,MAAM6B,MAAM,GAAGhB,KAAK,CAACO,OAAO,GAAGlB,SAAS,CAACd,CAAC;MAC1C,MAAM0C,MAAM,GAAGjB,KAAK,CAACQ,OAAO,GAAGnB,SAAS,CAACb,CAAC;;MAE1C;MACAU,WAAW,CAAEgC,IAAI,IAAK;QACpB,MAAMC,IAAI,GAAGD,IAAI,CAAC3C,CAAC,GAAG0C,MAAM,GAAG,GAAG;QAClC,MAAMG,IAAI,GAAGF,IAAI,CAAC1C,CAAC,GAAGwC,MAAM,GAAG,GAAG;QAElC,OAAO;UACLzC,CAAC,EAAE8C,IAAI,CAACC,GAAG,CAACP,cAAc,EAAEM,IAAI,CAACE,GAAG,CAACJ,IAAI,EAAEL,cAAc,CAAC,CAAC;UAAE;UAC7DtC,CAAC,EAAE4C;QACL,CAAC;MACH,CAAC,CAAC;MAEF9B,YAAY,CAAC;QAAEf,CAAC,EAAEyB,KAAK,CAACO,OAAO;QAAE/B,CAAC,EAAEwB,KAAK,CAACQ;MAAQ,CAAC,CAAC;IACtD;IAEA,IAAI,CAACX,SAAS,EAAE;MACd;MACA,IAAIN,aAAa,EAAE;QACjB,MAAMyB,MAAM,GAAGhB,KAAK,CAACO,OAAO,GAAGlB,SAAS,CAACd,CAAC;QAC1C,IAAI8C,IAAI,CAACG,GAAG,CAACR,MAAM,CAAC,GAAG,EAAE,EAAE;UACzB,MAAMS,SAAS,GAAGT,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;UACvCU,iBAAiB,CAACnC,aAAa,EAAEkC,SAAS,CAAC;UAC3CjC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1B;MACF;IACF,CAAC,MAAM;MACL,MAAMmC,aAAa,GAAGlC,aAAa,CAACE,gBAAgB,CAAC;MACrD,IAAIJ,aAAa,KAAKoC,aAAa,EAAE;QACnC,MAAMX,MAAM,GAAGhB,KAAK,CAACO,OAAO,GAAGlB,SAAS,CAACd,CAAC;QAC1C,MAAMkD,SAAS,GAAGT,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;QACvC,IAAIY,WAAW,GAAG,KAAK;QAEvB,IAAI,CAACrC,aAAa,KAAK,GAAG,IAAIA,aAAa,KAAK,GAAG,IAAIA,aAAa,KAAK,GAAG,IAAIA,aAAa,KAAK,GAAG,KAAKkC,SAAS,KAAK,EAAE,EAAE;UAC1HG,WAAW,GAAG,IAAI;QACpB;QAEA,IAAI,CAACrC,aAAa,KAAK,GAAG,IAAIA,aAAa,KAAK,GAAG,KAAKkC,SAAS,KAAK,CAAC,EAAE,EAAE;UACzEG,WAAW,GAAG,IAAI;QACpB;QAEA,IAAIP,IAAI,CAACG,GAAG,CAACR,MAAM,CAAC,GAAG,EAAE,IAAIY,WAAW,EAAE;UACxC;UACAF,iBAAiB,CAACnC,aAAa,EAAEkC,SAAS,CAAC;UAC3CjC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC;UACxBqC,sBAAsB,CAAC,CAAC;UACxBD,WAAW,GAAG,KAAK;QACrB;MACF;IACF;EACF,CAAC;;EAGG;EACA;EACA;EACA;EACA;;EAGJ,MAAME,aAAa,GAAGA,CAAA,KAAM;IAC1B1C,aAAa,CAAC,KAAK,CAAC;IACpBI,gBAAgB,CAAC,IAAI,CAAC;EACxB,CAAC;EAED,MAAMuC,gBAAgB,GAAGA,CAAA,KAAM;IAC7B3C,aAAa,CAAC,KAAK,CAAC;IACpBI,gBAAgB,CAAC,IAAI,CAAC;EACxB,CAAC;EAED,MAAMkC,iBAAiB,GAAGA,CAACpB,KAAK,EAAEmB,SAAS,KAAK;IAC9C3C,YAAY,CAAEkD,SAAS,IAAK;MAC1B,MAAMC,QAAQ,GAAG,CAAC,GAAGD,SAAS,CAAC;MAC/B,IAAIE,SAAS,EAAEC,SAAS;MACxB,QAAQ7B,KAAK;QACX,KAAK,GAAG;UACN4B,SAAS,GAAG,CAAC,CAAC,CAAC;UACfC,SAAS,GAAG,CAAC;UACb;QACF,KAAK,GAAG;UACND,SAAS,GAAG,CAAC;UACbC,SAAS,GAAG,CAAC,CAAC;UACd;QACF,KAAK,GAAG;UACND,SAAS,GAAG,CAAC,CAAC,CAAC;UACfC,SAAS,GAAG,CAAC;UACb;QACF,KAAK,GAAG;UACND,SAAS,GAAG,CAAC;UACbC,SAAS,GAAG,CAAC,CAAC;UACd;QACF,KAAK,GAAG;UACND,SAAS,GAAG,CAAC,CAAC,CAAC;UACfC,SAAS,GAAG,CAAC;UACb;QACF,KAAK,GAAG;UACND,SAAS,GAAG,CAAC;UACbC,SAAS,GAAG,CAAC,CAAC;UACd;QACF;UACE,OAAOF,QAAQ;MACnB;MACA,MAAMG,cAAc,GAAGH,QAAQ,CAACI,MAAM,CACnCC,CAAC,IAAKA,CAAC,CAACzE,QAAQ,CAACqE,SAAS,CAAC,KAAKC,SACnC,CAAC;;MAED;MACA;MACA;MACA;;MAEA,MAAMI,WAAW,GAAIC,KAAK,IAAK;QAC7B,MAAM;UAAE3E,QAAQ;UAAEC;QAAO,CAAC,GAAG0E,KAAK;QAClC,MAAM,CAACjE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAGZ,QAAQ;QAC1B,IAAI4E,WAAW,GAAG,CAAC,GAAG5E,QAAQ,CAAC;QAC/B,IAAI6E,SAAS,GAAG;UAAE,GAAG5E;QAAO,CAAC;;QAE7B;QACA,MAAM6E,YAAY,GAAGA,CAACC,OAAO,EAAEC,OAAO,KAAK;UACzC,IAAI/E,MAAM,CAAC8E,OAAO,CAAC,EAAE;YACnBF,SAAS,CAACG,OAAO,CAAC,GAAG/E,MAAM,CAAC8E,OAAO,CAAC;YACpC;UACF;QACF,CAAC;QAED,QAAQtC,KAAK;UACX,KAAK,GAAG;YACN,IAAImB,SAAS,GAAG,CAAC,EAAE;cACjB;cACAgB,WAAW,GAAG,CAAChE,CAAC,EAAED,CAAC,EAAE,CAACD,CAAC,CAAC;cACxB;cACA,IAAIT,MAAM,CAACC,CAAC,EAAE2E,SAAS,CAAC3E,CAAC,GAAGD,MAAM,CAACC,CAAC;;cAEpC;cACA4E,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB,CAAC,MAAM;cACL;cACAF,WAAW,GAAG,CAAC,CAAChE,CAAC,EAAED,CAAC,EAAED,CAAC,CAAC;cACxB,IAAIT,MAAM,CAACC,CAAC,EAAE2E,SAAS,CAAC3E,CAAC,GAAGD,MAAM,CAACC,CAAC;;cAEpC;cACA4E,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB;YACA;UAEF,KAAK,GAAG;YACN,IAAIlB,SAAS,GAAG,CAAC,EAAE;cACjBgB,WAAW,GAAG,CAAChE,CAAC,EAAED,CAAC,EAAE,CAACD,CAAC,CAAC;cACxB,IAAIT,MAAM,CAACM,CAAC,EAAEsE,SAAS,CAACtE,CAAC,GAAGN,MAAM,CAACM,CAAC;;cAEpC;cACAuE,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YAIxB,CAAC,MAAM;cACLF,WAAW,GAAG,CAAC,CAAChE,CAAC,EAAED,CAAC,EAAED,CAAC,CAAC;cACxB,IAAIT,MAAM,CAACM,CAAC,EAAEsE,SAAS,CAACtE,CAAC,GAAGN,MAAM,CAACM,CAAC;;cAEpC;cACAuE,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB;YACA;UAEF,KAAK,GAAG;YACN,IAAIlB,SAAS,GAAG,CAAC,EAAE;cACjBgB,WAAW,GAAG,CAACjE,CAAC,EAAE,CAACD,CAAC,EAAEE,CAAC,CAAC;cACxB,IAAIX,MAAM,CAACK,CAAC,EAAEuE,SAAS,CAACvE,CAAC,GAAGL,MAAM,CAACK,CAAC;;cAEpC;cACAwE,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB,CAAC,MAAM;cACLF,WAAW,GAAG,CAAC,CAACjE,CAAC,EAAED,CAAC,EAAEE,CAAC,CAAC;cACxB,IAAIX,MAAM,CAACK,CAAC,EAAEuE,SAAS,CAACvE,CAAC,GAAGL,MAAM,CAACK,CAAC;;cAEpC;cACAwE,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB;YACA;UAEF,KAAK,GAAG;YACN,IAAIlB,SAAS,GAAG,CAAC,EAAE;cACjBgB,WAAW,GAAG,CAAC,CAACjE,CAAC,EAAED,CAAC,EAAEE,CAAC,CAAC;cACxB,IAAIX,MAAM,CAACE,CAAC,EAAE0E,SAAS,CAAC1E,CAAC,GAAGF,MAAM,CAACE,CAAC;;cAEpC;cACA2E,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB,CAAC,MAAM;cACLF,WAAW,GAAG,CAACjE,CAAC,EAAE,CAACD,CAAC,EAAEE,CAAC,CAAC;cACxB,IAAIX,MAAM,CAACE,CAAC,EAAE0E,SAAS,CAAC1E,CAAC,GAAGF,MAAM,CAACE,CAAC;;cAEpC;cACA2E,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB;YACA;UAEF,KAAK,GAAG;YACN,IAAIlB,SAAS,GAAG,CAAC,EAAE;cACjBgB,WAAW,GAAG,CAAClE,CAAC,EAAEE,CAAC,EAAE,CAACD,CAAC,CAAC;cACxB,IAAIV,MAAM,CAACI,CAAC,EAAEwE,SAAS,CAACxE,CAAC,GAAGJ,MAAM,CAACI,CAAC;;cAEpC;cACAyE,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB,CAAC,MAAM;cACLF,WAAW,GAAG,CAAClE,CAAC,EAAE,CAACE,CAAC,EAAED,CAAC,CAAC;cACxB,IAAIV,MAAM,CAACI,CAAC,EAAEwE,SAAS,CAACxE,CAAC,GAAGJ,MAAM,CAACI,CAAC;;cAEpC;cACAyE,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB;YACA;UAEF,KAAK,GAAG;YACN,IAAIlB,SAAS,GAAG,CAAC,EAAE;cACjBgB,WAAW,GAAG,CAAClE,CAAC,EAAE,CAACE,CAAC,EAAED,CAAC,CAAC;cACxB,IAAIV,MAAM,CAACG,CAAC,EAAEyE,SAAS,CAACzE,CAAC,GAAGH,MAAM,CAACG,CAAC;;cAEpC;cACA0E,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB,CAAC,MAAM;cACLF,WAAW,GAAG,CAAClE,CAAC,EAAEE,CAAC,EAAE,CAACD,CAAC,CAAC;cACxB,IAAIV,MAAM,CAACG,CAAC,EAAEyE,SAAS,CAACzE,CAAC,GAAGH,MAAM,CAACG,CAAC;;cAEpC;cACA0E,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;cACtBA,YAAY,CAAC,GAAG,EAAE,GAAG,CAAC;YACxB;YACA;QACJ;QAEA,OAAO;UAAE,GAAGH,KAAK;UAAE3E,QAAQ,EAAE4E,WAAW;UAAE3E,MAAM,EAAE4E;QAAU,CAAC;MAC/D,CAAC;MAGD,MAAMI,OAAO,GAAG,CAAC,CAAC;MAClBV,cAAc,CAACW,OAAO,CAAEP,KAAK,IAAK;QAChCM,OAAO,CAACN,KAAK,CAAC5E,EAAE,CAAC,GAAG2E,WAAW,CAACC,KAAK,CAAC;MACxC,CAAC,CAAC;MAEF,OAAOP,QAAQ,CAACe,GAAG,CAAEV,CAAC,IAAKQ,OAAO,CAACR,CAAC,CAAC1E,EAAE,CAAC,IAAI0E,CAAC,CAAC;IAChD,CAAC,CAAC;EACJ,CAAC;EAED,MAAMW,YAAY,GAAG,MAAAA,CAAA,KAAY;IAC/B;IACA,MAAMC,eAAe,GAAG,EAAE,CAAC,CAAC;;IAE5B,MAAMC,KAAK,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAC5C,MAAMC,UAAU,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;;IAE9B,MAAMC,KAAK,GAAIC,EAAE,IAAK,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC,CAAC,CAAC;;IAEvE,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,eAAe,EAAEQ,CAAC,EAAE,EAAE;MACxC,MAAMC,UAAU,GAAGR,KAAK,CAAC9B,IAAI,CAACuC,KAAK,CAACvC,IAAI,CAACwC,MAAM,CAAC,CAAC,GAAGV,KAAK,CAACW,MAAM,CAAC,CAAC;MAClE,MAAMC,SAAS,GAAGX,UAAU,CAAC/B,IAAI,CAACuC,KAAK,CAACvC,IAAI,CAACwC,MAAM,CAAC,CAAC,GAAGT,UAAU,CAACU,MAAM,CAAC,CAAC;;MAE3E;MACApC,iBAAiB,CAACiC,UAAU,EAAEI,SAAS,CAAC;;MAExC;MACA,MAAMV,KAAK,CAAC,GAAG,CAAC;IAClB;EACF,CAAC;EAED,MAAMW,0BAA0B,GAAInF,SAAS,IAAK;IAChD;IACA,MAAMoF,cAAc,GAAIC,KAAK,IAAK;MAChC,MAAMC,QAAQ,GAAG;QACfC,KAAK,EAAE,GAAG;QACVC,MAAM,EAAE,GAAG;QACXC,IAAI,EAAE,GAAG;QACTC,KAAK,EAAE,GAAG;QACVC,GAAG,EAAE,GAAG;QACRC,MAAM,EAAE;MACV,CAAC;MACD,OAAON,QAAQ,CAACD,KAAK,CAAC,IAAI,GAAG;IAC/B,CAAC;;IAED;IACA;IACA,MAAMQ,SAAS,GAAIlC,KAAK,IAAK;MAC3B,MAAM,CAACjE,CAAC,EAAEoG,CAAC,EAAElG,CAAC,CAAC,GAAG+D,KAAK,CAAC3E,QAAQ;MAChC;MACA;MACA;MACA,IAAIU,CAAC,KAAM,CAAC,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIF,CAAC,KAAK,CAAC,CAAC,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIF,CAAC,KAAM,CAAC,IAAIE,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIF,CAAC,KAAK,CAAC,CAAC,IAAIE,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,OAAO,EAAE;IACX,CAAC;;IAED;IACA;IACA,MAAMmG,SAAS,GAAIpC,KAAK,IAAK;MAC3B,MAAM,CAACjE,CAAC,EAAEoG,CAAC,EAAElG,CAAC,CAAC,GAAG+D,KAAK,CAAC3E,QAAQ;MAChC;MACA;MACA;MACA;MACA,IAAIU,CAAC,KAAK,CAAC,CAAC,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIF,CAAC,KAAM,CAAC,IAAIE,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIF,CAAC,KAAK,CAAC,CAAC,IAAIE,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIF,CAAC,KAAM,CAAC,IAAIE,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,OAAO,EAAE;IACX,CAAC;;IAED;IACA,MAAMoG,SAAS,GAAIrC,KAAK,IAAK;MAC3B,MAAM,CAACjE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAG+D,KAAK,CAAC3E,QAAQ;MAChC;MACA;MACA;MACA;MACA;MACA,IAAIW,CAAC,KAAM,CAAC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIC,CAAC,KAAM,CAAC,IAAID,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIC,CAAC,KAAK,CAAC,CAAC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIC,CAAC,KAAK,CAAC,CAAC,IAAID,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,OAAO,EAAE;IACX,CAAC;;IAED;IACA,MAAMuG,SAAS,GAAItC,KAAK,IAAK;MAC3B,MAAM,CAACjE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAG+D,KAAK,CAAC3E,QAAQ;MAChC;MACA;MACA,IAAIW,CAAC,KAAM,CAAC,IAAID,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIC,CAAC,KAAM,CAAC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIC,CAAC,KAAK,CAAC,CAAC,IAAID,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,IAAIC,CAAC,KAAK,CAAC,CAAC,IAAID,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,OAAO,EAAE;IACX,CAAC;;IAED;IACA,MAAMwG,SAAS,GAAIvC,KAAK,IAAK;MAC3B,MAAM,CAACjE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAG+D,KAAK,CAAC3E,QAAQ;MAChC;MACA;MACA;MACA,IAAIW,CAAC,KAAK,CAAC,IAAIC,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC;MAChC,IAAID,CAAC,KAAK,CAAC,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MACjC,IAAID,CAAC,KAAK,CAAC,CAAC,IAAIC,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC;MACjC,IAAID,CAAC,KAAK,CAAC,CAAC,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,OAAO,EAAE;IACX,CAAC;;IAED;IACA,MAAMuG,SAAS,GAAIxC,KAAK,IAAK;MAC3B,MAAM,CAACjE,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,GAAG+D,KAAK,CAAC3E,QAAQ;MAChC;MACA;MACA,IAAIW,CAAC,KAAM,CAAC,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAID,CAAC,KAAM,CAAC,IAAIC,CAAC,KAAM,CAAC,EAAG,OAAO,CAAC;MACnC,IAAID,CAAC,KAAK,CAAC,CAAC,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,CAAC;MAClC,IAAID,CAAC,KAAK,CAAC,CAAC,IAAIC,CAAC,KAAM,CAAC,EAAE,OAAO,CAAC;MAClC,OAAO,EAAE;IACX,CAAC;;IAED;IACA,MAAMwG,eAAe,GAAI3G,IAAI,IAAK;MAChC,IAAI4G,QAAQ,GAAG,EAAE;MACjB,QAAQ5G,IAAI;QACV,KAAK,GAAG;UAAE;YACR4G,QAAQ,GAAGrG,SAAS,CAACwD,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIyE,CAAC,CAACxE,MAAM,CAACC,CAAC,CAAC;YACnEmH,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKX,SAAS,CAACU,CAAC,CAAC,GAAGV,SAAS,CAACW,CAAC,CAAC,CAAC;YACpD,OAAOH,QAAQ,CAAClC,GAAG,CAACV,CAAC,IAAI2B,cAAc,CAAC3B,CAAC,CAACxE,MAAM,CAACC,CAAC,CAAC,CAAC,CAACuH,IAAI,CAAC,EAAE,CAAC;UAC/D;QACA,KAAK,GAAG;UAAE;YACRJ,QAAQ,GAAGrG,SAAS,CAACwD,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIyE,CAAC,CAACxE,MAAM,CAACM,CAAC,CAAC;YACpE8G,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKT,SAAS,CAACQ,CAAC,CAAC,GAAGR,SAAS,CAACS,CAAC,CAAC,CAAC;YACpD,OAAOH,QAAQ,CAAClC,GAAG,CAACV,CAAC,IAAI2B,cAAc,CAAC3B,CAAC,CAACxE,MAAM,CAACM,CAAC,CAAC,CAAC,CAACkH,IAAI,CAAC,EAAE,CAAC;UAC/D;QACA,KAAK,GAAG;UAAE;YACRJ,QAAQ,GAAGrG,SAAS,CAACwD,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIyE,CAAC,CAACxE,MAAM,CAACK,CAAC,CAAC;YACnE+G,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKR,SAAS,CAACO,CAAC,CAAC,GAAGP,SAAS,CAACQ,CAAC,CAAC,CAAC;YACpD,OAAOH,QAAQ,CAAClC,GAAG,CAACV,CAAC,IAAI2B,cAAc,CAAC3B,CAAC,CAACxE,MAAM,CAACK,CAAC,CAAC,CAAC,CAACmH,IAAI,CAAC,EAAE,CAAC;UAC/D;QACA,KAAK,GAAG;UAAE;YACRJ,QAAQ,GAAGrG,SAAS,CAACwD,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIyE,CAAC,CAACxE,MAAM,CAACE,CAAC,CAAC;YACpEkH,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKP,SAAS,CAACM,CAAC,CAAC,GAAGN,SAAS,CAACO,CAAC,CAAC,CAAC;YACpD,OAAOH,QAAQ,CAAClC,GAAG,CAACV,CAAC,IAAI2B,cAAc,CAAC3B,CAAC,CAACxE,MAAM,CAACE,CAAC,CAAC,CAAC,CAACsH,IAAI,CAAC,EAAE,CAAC;UAC/D;QACA,KAAK,GAAG;UAAE;YACRJ,QAAQ,GAAGrG,SAAS,CAACwD,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAIyE,CAAC,CAACxE,MAAM,CAACG,CAAC,CAAC;YACpEiH,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKN,SAAS,CAACK,CAAC,CAAC,GAAGL,SAAS,CAACM,CAAC,CAAC,CAAC;YACpD,OAAOH,QAAQ,CAAClC,GAAG,CAACV,CAAC,IAAI2B,cAAc,CAAC3B,CAAC,CAACxE,MAAM,CAACG,CAAC,CAAC,CAAC,CAACqH,IAAI,CAAC,EAAE,CAAC;UAC/D;QACA,KAAK,GAAG;UAAE;YACRJ,QAAQ,GAAGrG,SAAS,CAACwD,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,IAAIyE,CAAC,CAACxE,MAAM,CAACI,CAAC,CAAC;YACnEgH,QAAQ,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKL,SAAS,CAACI,CAAC,CAAC,GAAGJ,SAAS,CAACK,CAAC,CAAC,CAAC;YACpD,OAAOH,QAAQ,CAAClC,GAAG,CAACV,CAAC,IAAI2B,cAAc,CAAC3B,CAAC,CAACxE,MAAM,CAACI,CAAC,CAAC,CAAC,CAACoH,IAAI,CAAC,EAAE,CAAC;UAC/D;QACA;UACE,OAAO,EAAE;MACb;IACF,CAAC;;IAED;IACA,MAAMC,SAAS,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAChD,OAAOA,SAAS,CAACvC,GAAG,CAAC1E,IAAI,IAAI2G,eAAe,CAAC3G,IAAI,CAAC,CAAC,CAACgH,IAAI,CAAC,EAAE,CAAC;EAC9D,CAAC;;EAKD;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAGA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAGA,SAASE,oBAAoBA,CAAA,EAAG;IAC9B,OAAO,CACL;MACE5H,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACrBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MACpBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACpBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACnBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACtBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;MACrBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACrBC,MAAM,EAAE,CAAC;IACX,CAAC,EACD;MACEF,EAAE,EAAE,KAAK;MACTC,QAAQ,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACpBC,MAAM,EAAE,CAAC;IACX,CAAC,CACF;EACH;EAGA,SAAS2H,sBAAsBA,CAACC,UAAU,EAAE;IAC5C;IACA;;IAEE,MAAMH,SAAS,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAChD;IACA,MAAMI,eAAe,GAAG;MACtB,GAAG,EAAE,OAAO;MACZ,GAAG,EAAE,QAAQ;MACb,GAAG,EAAE,MAAM;MACX,GAAG,EAAE,OAAO;MACZ,GAAG,EAAE,KAAK;MACV,GAAG,EAAE;IACP,CAAC;;IAED;IACA,IAAI1D,QAAQ,GAAGuD,oBAAoB,CAAC,CAAC;;IAErC;IACA,MAAMI,qBAAqB,GAAIlC,CAAC,IAAK;MACnC;MACA,QAAOA,CAAC;QACN,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAAI;QAC7B,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAAG;QAC5B,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAAK;QAC7B,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,EAAE,CAAC,CAAC;QAAK;QAC7B;UACE,OAAO,GAAG;MACd;IACF,CAAC;IAED,MAAMmC,qBAAqB,GAAInC,CAAC,IAAK;MACnC,QAAOA,CAAC;QACN,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QACzB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAC1B,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB;UACE,OAAO,GAAG;MACd;IACF,CAAC;IAED,MAAMoC,qBAAqB,GAAIpC,CAAC,IAAK;MACnC,QAAOA,CAAC;QACN,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC;QACvB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC;QACvB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,EAAC,CAAC,CAAC;QACxB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAC,CAAC,CAAC;QACxB;UACE,OAAO,GAAG;MACd;IACF,CAAC;IAGD,MAAMqC,qBAAqB,GAAIrC,CAAC,IAAK;MACnC,QAAOA,CAAC;QACN,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QACvB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC,CAAC;QACzB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAC,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QACxB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QAC1B;UACE,OAAO,GAAG;MACd;IACF,CAAC;IAED,MAAMsC,qBAAqB,GAAItC,CAAC,IAAK;MACnC,QAAOA,CAAC;QACN,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC;QACvB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC,CAAC;QACzB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC,EAAC,CAAC,CAAC;QACxB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QAC1B;UACE,OAAO,GAAG;MACd;IACF,CAAC;IAGD,MAAMuC,qBAAqB,GAAIvC,CAAC,IAAK;MACnC,QAAOA,CAAC;QACN,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QACvB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAC,CAAC,CAAC;QACvB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAC,CAAC,CAAC,EAAC,CAAC,CAAC,CAAC;QACxB,KAAK,CAAC;UAAE,OAAO,CAAC,CAAC,EAAE,CAAC,CAAC,EAAC,CAAC,CAAC;QACxB;UACE,OAAO,GAAG;MACd;IACF,CAAC;IACD;IACA;;IAEA;IACA,SAASwC,mBAAmBA,CAAC3H,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;MACpC,OAAOwD,QAAQ,CAACkE,IAAI,CAAC7D,CAAC,IACpBA,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAKU,CAAC,IACnB+D,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAKW,CAAC,IACnB8D,CAAC,CAACzE,QAAQ,CAAC,CAAC,CAAC,KAAKY,CACpB,CAAC;IACH;;IAEA;IACA,IAAI2H,MAAM,GAAG,CAAC;IACd,KAAK,IAAI9H,IAAI,IAAIiH,SAAS,EAAE;MAC1B,MAAMc,SAAS,GAAGX,UAAU,CAACY,KAAK,CAACF,MAAM,EAAEA,MAAM,GAAC,CAAC,CAAC,CAAC,CAAC;MACtDA,MAAM,IAAI,CAAC;MAEX,KAAK,IAAI1C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;QAC1B,MAAM6C,MAAM,GAAGF,SAAS,CAAC3C,CAAC,CAAC,CAAC,CAAE;QAC9B,MAAM8C,WAAW,GAAGb,eAAe,CAACY,MAAM,CAAC,IAAI,SAAS;QAExD,IAAIE,GAAG;QACP,IAAInI,IAAI,KAAK,GAAG,EAAE;UAChBmI,GAAG,GAAGb,qBAAqB,CAAClC,CAAC,CAAC;QAChC,CAAC,MAAM,IAAIpF,IAAI,KAAK,GAAG,EAAE;UACvBmI,GAAG,GAAGZ,qBAAqB,CAACnC,CAAC,CAAC;QAChC,CAAC,MACI,IAAIpF,IAAI,KAAK,GAAG,EAAE;UAAEmI,GAAG,GAAGX,qBAAqB,CAACpC,CAAC,CAAC;QAAE,CAAC,MACrD,IAAIpF,IAAI,KAAK,GAAG,EAAE;UAAEmI,GAAG,GAAGV,qBAAqB,CAACrC,CAAC,CAAC;QAAE,CAAC,MACrD,IAAIpF,IAAI,KAAK,GAAG,EAAE;UAAEmI,GAAG,GAAGR,qBAAqB,CAACvC,CAAC,CAAC;QAAE,CAAC,MACrD,IAAIpF,IAAI,KAAK,GAAG,EAAE;UAAEmI,GAAG,GAAGT,qBAAqB,CAACtC,CAAC,CAAC;QAAE;QAEzD,MAAM,CAACnF,CAAC,EAACC,CAAC,EAACC,CAAC,CAAC,GAAGgI,GAAG;QACnB;QACA,MAAMjE,KAAK,GAAG0D,mBAAmB,CAAC3H,CAAC,EAACC,CAAC,EAACC,CAAC,CAAC;QACxC,IAAI+D,KAAK,EAAE;UACTA,KAAK,CAAC1E,MAAM,CAACQ,IAAI,CAAC,GAAGkI,WAAW;QAClC;MACF;IACF;IACA;IACA1H,YAAY,CAACmD,QAAQ,CAAC;;IAEtB;IACA;EACF;;EAGE;EACA,MAAMyE,kBAAkB,GAAG,MAAAA,CAAA,KAAY;IACrC,MAAMhB,UAAU,GAAG1B,0BAA0B,CAACnF,SAAS,CAAC;IAExD,IAAI;MACF;MACA,MAAM8H,WAAW,GAAG,MAAMC,KAAK,CAAC,GAAGpJ,YAAY,gBAAgB,EAAE;QAC/DqJ,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB,CAAC;QAC/CpG,IAAI,EAAEqG,IAAI,CAACC,SAAS,CAAC;UAAEC,SAAS,EAAEvB;QAAW,CAAC;MAChD,CAAC,CAAC;MACF,MAAMwB,YAAY,GAAG,MAAMP,WAAW,CAACQ,IAAI,CAAC,CAAC;MAE7C,IAAI,CAACD,YAAY,CAACE,KAAK,EAAE;QACvBC,OAAO,CAACC,GAAG,CAAC,4CAA4C,CAAC;QACzD5H,gBAAgB,CAAC,IAAI,CAAC;QACtB;MACF;;MAEA;MACA,IAAIwH,YAAY,CAACK,KAAK,KAAK7B,UAAU,EAAE;QACrCD,sBAAsB,CAACyB,YAAY,CAACK,KAAK,CAAC;QAC1CF,OAAO,CAACC,GAAG,CAAC,8FAA8F,CAAC;MAC7G;;MAEA;MACA,MAAME,QAAQ,GAAG,MAAMZ,KAAK,CAAC,GAAGpJ,YAAY,QAAQ,EAAE;QACpDqJ,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UAAE,cAAc,EAAE;QAAmB,CAAC;QAC/CpG,IAAI,EAAEqG,IAAI,CAACC,SAAS,CAAC;UAAEC,SAAS,EAAEC,YAAY,CAACK;QAAM,CAAC;MACxD,CAAC,CAAC;MACF,MAAME,SAAS,GAAG,MAAMD,QAAQ,CAACL,IAAI,CAAC,CAAC;MAGvC,IAAIM,SAAS,CAACC,QAAQ,CAAC,CAAC,CAAC,KAAK,kBAAkB,EAAE;QAChDL,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;QAClD5H,gBAAgB,CAAC,IAAI,CAAC;QACtB;MACF;MAEAA,gBAAgB,CAAC+H,SAAS,CAACC,QAAQ,CAAC;MAEpCL,OAAO,CAACC,GAAG,CAAC,8DAA8D,CAAC;IAC7E,CAAC,CAAC,OAAOK,GAAG,EAAE;MACZN,OAAO,CAACO,KAAK,CAAC,2BAA2B,EAAED,GAAG,CAAC;IACjD;EACF,CAAC;;EAED;EACA,MAAME,aAAa,GAAGA,CAAA,KAAM;IAC1B,IAAI,CAACpI,aAAa,IAAIA,aAAa,CAACqE,MAAM,KAAK,CAAC,EAAE;MAChDuD,OAAO,CAACC,GAAG,CAAC,iDAAiD,CAAC;MAC9D;IACF;IACA;IACAxH,YAAY,CAAC,IAAI,CAAC;IAClBF,mBAAmB,CAAC,CAAC,CAAC;IACtBkI,cAAc,CAAC,CAAC,CAAC;EACnB,CAAC;;EAIH;EACA;;EAEA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;;EAEA;EACA;;EAEA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;;EAGA,MAAMA,cAAc,GAAIC,KAAK,IAAK;IAChC;IACA,IAAIA,KAAK,IAAItI,aAAa,CAACqE,MAAM,EAAE;MACjCkE,kBAAkB,CAAC,CAAC;MACpB;IACF;IAEA,MAAM1H,KAAK,GAAGb,aAAa,CAACsI,KAAK,CAAC;IAClC;IACA,IAAIzH,KAAK,KAAK,kBAAkB,EAAE;MAChC0H,kBAAkB,CAAC,CAAC;MACpBlI,YAAY,CAAC,KAAK,CAAC;MACnB;IACF;;IAEA;IACA,IAAI2B,SAAS,GAAG,EAAE;IAClB,IAAInB,KAAK,KAAK,GAAG,IAAIA,KAAK,KAAK,GAAG,EAAE;MAClCmB,SAAS,GAAG,CAAC,EAAE;IACjB;;IAEA;IACAwG,iBAAiB,CAAC3H,KAAK,EAAEmB,SAAS,CAAC;;IAEnC;IACA;EACF,CAAC;EAED,MAAMI,sBAAsB,GAAGA,CAAA,KAAM;IACnC;IACA,MAAMvB,KAAK,GAAGb,aAAa,CAACE,gBAAgB,CAAC;IAC7CuI,qBAAqB,CAAC5H,KAAK,CAAC;;IAE5B;IACA,MAAM6H,SAAS,GAAGxI,gBAAgB,GAAG,CAAC;IACtCC,mBAAmB,CAACuI,SAAS,CAAC;IAC9BL,cAAc,CAACK,SAAS,CAAC;EAC3B,CAAC;EAID,MAAMF,iBAAiB,GAAGA,CAAC3H,KAAK,EAAEmB,SAAS,KAAK;IAC9CgC,UAAU,CAAC,MAAM;MACf;MACA,MAAM2E,YAAY,GAAG3H,QAAQ,CAAC4H,gBAAgB,CAAC,0BAA0B/H,KAAK,IAAI,CAAC;MAEnF8H,YAAY,CAACrF,OAAO,CAAEzE,IAAI,IAAK;QAC7B;QACA,MAAMgK,KAAK,GAAG7H,QAAQ,CAAC8H,aAAa,CAAC,KAAK,CAAC;QAC3CD,KAAK,CAACE,SAAS,CAACC,GAAG,CAAC,gBAAgB,CAAC;QAErC,IAAInI,KAAK,KAAK,GAAG,EAAE;UACjBgI,KAAK,CAACI,SAAS,GAAGjH,SAAS,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG;QAC7C,CAAC,MAAM;UACL6G,KAAK,CAACI,SAAS,GAAGjH,SAAS,GAAG,CAAC,GAAG,GAAG,GAAG,GAAG;QAC7C;;QAEA;QACAnD,IAAI,CAACqK,WAAW,CAACL,KAAK,CAAC;MACzB,CAAC,CAAC;IACJ,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;EACX,CAAC;;EAMD;EACA,MAAMJ,qBAAqB,GAAI5H,KAAK,IAAK;IACvC,MAAM8H,YAAY,GAAG3H,QAAQ,CAAC4H,gBAAgB,CAAC,0BAA0B/H,KAAK,IAAI,CAAC;IAEnF8H,YAAY,CAACrF,OAAO,CAAEzE,IAAI,IAAK;MAC7B,MAAMgK,KAAK,GAAGhK,IAAI,CAACsK,aAAa,CAAC,iBAAiB,CAAC;MACnD,IAAIN,KAAK,EAAEA,KAAK,CAACO,MAAM,CAAC,CAAC;IAC3B,CAAC,CAAC;EACJ,CAAC;EAGD,MAAMb,kBAAkB,GAAGA,CAAA,KAAM;IAC/B,MAAMc,UAAU,GAAGrI,QAAQ,CAAC8H,aAAa,CAAC,KAAK,CAAC;IAChDO,UAAU,CAACN,SAAS,CAACC,GAAG,CAAC,iBAAiB,CAAC;IAC3CK,UAAU,CAACC,SAAS,GAAG,iBAAiB;IACxCtI,QAAQ,CAACC,IAAI,CAACiI,WAAW,CAACG,UAAU,CAAC;IAErCrF,UAAU,CAAC,MAAM;MACfqF,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;IACvB,CAAC,EAAE,IAAI,CAAC;EACV,CAAC;EAGD,MAAMxF,KAAK,GAAIC,EAAE,IAAK,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;;EAGvE;EACA,MAAM0F,YAAY,GAAGA,CAAA,KACnBnK,SAAS,CAACmE,GAAG,CAAER,KAAK,IAAK;IACvB,MAAM;MAAE5E,EAAE;MAAEC,QAAQ;MAAEC;IAAO,CAAC,GAAG0E,KAAK;IACtC,MAAM,CAACyG,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC,GAAGtL,QAAQ;IAE7B,oBACEH,OAAA;MAEE0L,SAAS,EAAC,OAAO;MACjB,UAAQH,EAAG,CAAK;MAAA;MAChB,UAAQC,EAAG;MACX,UAAQC,EAAG;MACXxI,KAAK,EAAE;QACL9C,QAAQ,EAAE,UAAU;QACpBwL,KAAK,EAAE,MAAM;QACbC,MAAM,EAAE,MAAM;QACdC,SAAS,EAAE,eAAeN,EAAE,GAAG,EAAE,OAAO,CAACC,EAAE,GAAG,EAAE,OAAOC,EAAE,GAAG,EAAE,KAAK;QACnEK,cAAc,EAAE;MAClB,CAAE;MAAAC,QAAA,EAEDC,MAAM,CAACC,OAAO,CAAC7L,MAAM,CAAC,CAACkF,GAAG,CAAC,CAAC,CAAC1E,IAAI,EAAE4F,KAAK,CAAC,kBACxCxG,OAAA;QAEE0L,SAAS,EAAC,YAAY;QACtB,aAAW9K,IAAK,CAAC;QAAA;QACjBqC,KAAK,EAAE;UACL9C,QAAQ,EAAE,UAAU;UACpBwL,KAAK,EAAE,MAAM;UACbC,MAAM,EAAE,MAAM;UACdM,MAAM,EAAE,iBAAiB;UACzBC,eAAe,EAAE3F,KAAK;UACtBqF,SAAS,EAAEO,gBAAgB,CAACxL,IAAI,CAAC;UACjCsC,MAAM,EAAE;QACV;MAAE,GAXGtC,IAAI;QAAAyL,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAYV,CACF;IAAC,GA5BGtM,EAAE;MAAAmM,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OA6BJ,CAAC;EAEV,CAAC,CAAC;;EAEJ;EACA,MAAMJ,gBAAgB,GAAIxL,IAAI,IAAK;IACjC,QAAQA,IAAI;MACV,KAAK,GAAG;QACN,OAAO,iCAAiC;MAC1C,KAAK,GAAG;QACN,OAAO,kCAAkC;MAC3C,KAAK,GAAG;QACN,OAAO,kBAAkB;MAC3B,KAAK,GAAG;QACN,OAAO,kCAAkC;MAC3C,KAAK,GAAG;QACN,OAAO,kCAAkC;MAC3C,KAAK,GAAG;QACN,OAAO,iCAAiC;MAC1C;QACE,OAAO,EAAE;IACb;EACF,CAAC;EAID,oBACEZ,OAAA;IAAA+L,QAAA,gBACE/L,OAAA;MAAK0L,SAAS,EAAC,kBAAkB;MAAAK,QAAA,gBAC/B/L,OAAA;QAAQ0L,SAAS,EAAC,UAAU;QAACe,OAAO,EAAElH,YAAa;QAAAwG,QAAA,EAAC;MAAQ;QAAAM,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,eACrExM,OAAA;QAAQ0L,SAAS,EAAC,eAAe;QAACe,OAAO,EAAEzD,kBAAmB;QAAA+C,QAAA,EAAC;MAAa;QAAAM,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC,eACrFxM,OAAA;QAAQ0L,SAAS,EAAC,UAAU;QAACe,OAAO,EAAEtC,aAAc;QAAA4B,QAAA,EAAC;MAAQ;QAAAM,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAQ,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACnE,CAAC,eACNxM,OAAA;MACE0L,SAAS,EAAC,gBAAgB;MAC1BgB,WAAW,EAAErK,eAAgB;MAC7BsK,WAAW,EAAExJ,eAAgB;MAC7ByJ,SAAS,EAAExI,aAAc;MACzByI,YAAY,EAAExI,gBAAiB;MAAA0H,QAAA,eAE/B/L,OAAA;QACE0L,SAAS,EAAC,MAAM;QAChBzI,KAAK,EAAE;UACL4I,SAAS,EAAE,WAAWtK,QAAQ,CAACV,CAAC,gBAAgBU,QAAQ,CAACT,CAAC;QAC5D,CAAE;QAAAiL,QAAA,EAEDT,YAAY,CAAC;MAAC;QAAAe,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACZ;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACH,CAAC;AAGV,CAAC;AAACtL,EAAA,CA//BID,IAAI;AAAA6L,EAAA,GAAJ7L,IAAI;AAigCV,eAAeA,IAAI,CAAC,CAAE;AAAA,IAAA6L,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}