{"ast":null,"code":"/* eslint-disable default-case */import React,{useState,useEffect}from\"react\";import\"./Cube.css\";import API_BASE_URL from\"../config\";// const defaultColors = {\n//   U: \"blue\",   // Up\n//   D: \"green\",  // Down\n//   F: \"orange\", // Front\n//   B: \"red\",    // Back\n//   L: \"white\",  // Left\n//   R: \"yellow\", // Right\n// };\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const initialCubeState=[{id:\"UBL\",position:[-1,1,-1],colors:{U:\"blue\",B:\"red\",L:\"yellow\"}},{id:\"UBR\",position:[1,1,-1],colors:{U:\"blue\",B:\"red\",R:\"white\"}},{id:\"UFL\",position:[-1,1,1],colors:{U:\"blue\",F:\"orange\",L:\"yellow\"}},{id:\"UFR\",position:[1,1,1],colors:{U:\"blue\",F:\"orange\",R:\"white\"}},{id:\"DBL\",position:[-1,-1,-1],colors:{D:\"green\",B:\"red\",L:\"yellow\"}},{id:\"DBR\",position:[1,-1,-1],colors:{D:\"green\",B:\"red\",R:\"white\"}},{id:\"DFL\",position:[-1,-1,1],colors:{D:\"green\",F:\"orange\",L:\"yellow\"}},{id:\"DFR\",position:[1,-1,1],colors:{D:\"green\",F:\"orange\",R:\"white\"}}];// Helper that decides exactly which layer to rotate, given the face clicked\n// and the (x,y,z) position of that cubie.\nfunction getLayerFromFaceAndPosition(face,x,y,z){// Convert to integers, since dataset attributes come as strings\nx=parseInt(x,10);y=parseInt(y,10);z=parseInt(z,10);switch(face){case\"U\":// Only rotate top layer if y=1\nreturn y===1?\"U\":null;case\"D\":// Only rotate bottom layer if y=-1\nreturn y===-1?\"D\":null;case\"F\":// Only rotate front layer if z=1\nreturn z===1?\"F\":null;case\"B\":// Only rotate back layer if z=-1\nreturn z===-1?\"B\":null;case\"R\":// Only rotate right layer if x=1\nreturn x===1?\"R\":null;case\"L\":// Only rotate left layer if x=-1\nreturn x===-1?\"L\":null;default:return null;}}const Cube=()=>{const[cubeState,setCubeState]=useState(initialCubeState);const[shouldSolve,setShouldSolve]=useState(false);const[rotation,setRotation]=useState({x:-30,y:45});// Whole-cube rotation\nconst[isDragging,setIsDragging]=useState(false);const[dragStart,setDragStart]=useState({x:0,y:0});const[selectedLayer,setSelectedLayer]=useState(null);const[solutionSteps,setSolutionSteps]=useState([]);const[currentStepIndex,setCurrentStepIndex]=useState(0);// --- MOUSE EVENTS ---\nconst handleMouseDown=event=>{// 1) Check if you clicked on a specific face via data-face\nconst faceElement=event.target.closest(\".cubie-face\");if(faceElement){const face=faceElement.dataset.face;// e.g., \"U\", \"R\", ...\nif(face){// Grab the parent .cubie to read its data-x, data-y, data-z\nconst cubieEl=faceElement.closest(\".cubie\");if(cubieEl){const{x,y,z}=cubieEl.dataset;// Figure out the *actual* layer to rotate, if any\nconst layer=getLayerFromFaceAndPosition(face,x,y,z);if(layer){setSelectedLayer(layer);setDragStart({x:event.clientX,y:event.clientY});return;// Skip rotating the whole cube\n}}}}// 2) Otherwise, rotate the entire cube\nsetIsDragging(true);setDragStart({x:event.clientX,y:event.clientY});};const handleMouseMove=event=>{// A) If dragging the whole cube\nconst MAX_ROTATION_X=90;// Maximum x rotation\nconst MIN_ROTATION_X=-90;// Minimum x rotation\nif(isDragging){const deltaX=event.clientX-dragStart.x;const deltaY=event.clientY-dragStart.y;// Update x with the deltaY, but clamp it between MIN_ROTATION_X and MAX_ROTATION_X\nsetRotation(prev=>{const newX=prev.x-deltaY*0.3;const newY=prev.y+deltaX*0.3;return{x:Math.max(MIN_ROTATION_X,Math.min(newX,MAX_ROTATION_X)),// Clamp x\ny:newY};});setDragStart({x:event.clientX,y:event.clientY});}// B) If dragging a face to rotate that layer\nif(selectedLayer){const deltaX=event.clientX-dragStart.x;if(Math.abs(deltaX)>30){const direction=deltaX>0?90:-90;rotateLayerCubies(selectedLayer,direction);setSelectedLayer(null);// Prevent repeated rotations on same drag\n}}};const handleMouseUp=()=>{setIsDragging(false);setSelectedLayer(null);};const handleMouseLeave=()=>{setIsDragging(false);setSelectedLayer(null);};const rotateLayerCubies=(layer,direction)=>{setCubeState(prevState=>{const newState=[...prevState];let axisIndex,axisValue;switch(layer){case\"U\":axisIndex=1;// y\naxisValue=1;break;case\"D\":axisIndex=1;axisValue=-1;break;case\"F\":axisIndex=2;// z\naxisValue=1;break;case\"B\":axisIndex=2;axisValue=-1;break;case\"R\":axisIndex=0;// x\naxisValue=1;break;case\"L\":axisIndex=0;axisValue=-1;break;default:return newState;}const affectedCubies=newState.filter(c=>c.position[axisIndex]===axisValue);// Helper to update a sticker only if it exists.\nconst updateColor=(colors,target,value)=>{return colors.hasOwnProperty(target)?value:undefined;};const rotateCubie=cubie=>{const{position,colors}=cubie;const[x,y,z]=position;let newPosition=[...position];let newColors={...colors};// Helper function: assign oldFace to newFace if oldFace existed, then delete oldFace\nconst reassignFace=(oldFace,newFace)=>{if(colors[oldFace]){newColors[newFace]=colors[oldFace];//delete newColors[oldFace];\n}};switch(layer){case\"U\":if(direction>0){// +90 around U\nnewPosition=[z,y,-x];// Keep U face\nif(colors.U)newColors.U=colors.U;//F->R, R->B, B->L, L->F\nreassignFace(\"F\",\"R\");reassignFace(\"R\",\"B\");reassignFace(\"B\",\"L\");reassignFace(\"L\",\"F\");}else{// -90 around U\nnewPosition=[-z,y,x];if(colors.U)newColors.U=colors.U;// F->L, L->B, B->R, R->F (the reverse mapping)\nreassignFace(\"F\",\"L\");reassignFace(\"L\",\"B\");reassignFace(\"B\",\"R\");reassignFace(\"R\",\"F\");}break;case\"D\":if(direction>0){newPosition=[z,y,-x];if(colors.D)newColors.D=colors.D;// F->L, L->B, B->R, R->F (for example)\nreassignFace(\"F\",\"R\");reassignFace(\"L\",\"F\");reassignFace(\"B\",\"L\");reassignFace(\"R\",\"B\");}else{newPosition=[-z,y,x];if(colors.D)newColors.D=colors.D;// F->R, R->B, B->L, L->F\nreassignFace(\"F\",\"L\");reassignFace(\"R\",\"F\");reassignFace(\"B\",\"R\");reassignFace(\"L\",\"B\");}break;case\"F\":if(direction>0){newPosition=[y,-x,z];if(colors.F)newColors.F=colors.F;// U->L, L->D, D->R, R->U\nreassignFace(\"R\",\"D\");reassignFace(\"U\",\"R\");reassignFace(\"L\",\"U\");reassignFace(\"D\",\"L\");}else{newPosition=[-y,x,z];if(colors.F)newColors.F=colors.F;// U->R, R->D, D->L, L->U\nreassignFace(\"L\",\"D\");reassignFace(\"U\",\"L\");reassignFace(\"R\",\"U\");reassignFace(\"D\",\"R\");}break;case\"B\":if(direction>0){newPosition=[-y,x,z];if(colors.B)newColors.B=colors.B;// U->R, R->D, D->L, L->U\nreassignFace(\"L\",\"D\");reassignFace(\"U\",\"L\");reassignFace(\"R\",\"U\");reassignFace(\"D\",\"R\");}else{newPosition=[y,-x,z];if(colors.B)newColors.B=colors.B;// U->L, L->D, D->R, R->U\nreassignFace(\"R\",\"D\");reassignFace(\"U\",\"R\");reassignFace(\"L\",\"U\");reassignFace(\"D\",\"L\");}break;case\"R\":if(direction>0){newPosition=[x,z,-y];if(colors.R)newColors.R=colors.R;// U->F, F->D, D->B, B->U\nreassignFace(\"F\",\"U\");reassignFace(\"U\",\"B\");reassignFace(\"B\",\"D\");reassignFace(\"D\",\"F\");}else{newPosition=[x,-z,y];if(colors.R)newColors.R=colors.R;// U->B, B->D, D->F, F->U\nreassignFace(\"B\",\"U\");reassignFace(\"U\",\"F\");reassignFace(\"F\",\"D\");reassignFace(\"D\",\"B\");}break;case\"L\":if(direction>0){newPosition=[x,-z,y];if(colors.L)newColors.L=colors.L;// U->B, B->D, D->F, F->U\nreassignFace(\"B\",\"U\");reassignFace(\"U\",\"F\");reassignFace(\"F\",\"D\");reassignFace(\"D\",\"B\");}else{newPosition=[x,z,-y];if(colors.L)newColors.L=colors.L;// U->F, F->D, D->B, B->U\nreassignFace(\"F\",\"U\");reassignFace(\"U\",\"B\");reassignFace(\"B\",\"D\");reassignFace(\"D\",\"F\");}break;}return{...cubie,position:newPosition,colors:newColors};};const updated={};affectedCubies.forEach(cubie=>{updated[cubie.id]=rotateCubie(cubie);});return newState.map(c=>updated[c.id]||c);});};const scrambleCube=async()=>{// Decide how many random moves you want:\nconst SCRAMBLE_LENGTH=15;// or 20, etc.\nconst faces=[\"U\",\"D\",\"L\",\"R\",\"F\",\"B\"];const directions=[90,-90];// clockwise or counterclockwise\nconst delay=ms=>new Promise(resolve=>setTimeout(resolve,ms));// Delay function\nfor(let i=0;i<SCRAMBLE_LENGTH;i++){const randomFace=faces[Math.floor(Math.random()*faces.length)];const randomDir=directions[Math.floor(Math.random()*directions.length)];// rotateLayerCubies is your existing method to do 90Â° turns\nrotateLayerCubies(randomFace,randomDir);// Wait for a timeout before the next move (e.g., 300ms between moves)\nawait delay(300);}};const flattenCubeStateByPosition=cubeState=>{// Convert color strings to single-letter codes\nconst getColorLetter=color=>{const colorMap={white:\"W\",yellow:\"Y\",blue:\"B\",green:\"G\",red:\"R\",orange:\"O\"};return colorMap[color]||\"?\";};// ========== U FACE ========== \n// y === 1, have a U sticker\nconst getUIndex=cubie=>{const[x,_,z]=cubie.position;// Example: top-left => 0, top-right => 1, bottom-left => 2, bottom-right => 3\n// Fill in the coordinates that physically match each slot.\n// (Just like your existing getUIndex)\nif(x===1&&z===-1)return 2;if(x===-1&&z===-1)return 3;if(x===1&&z===1)return 0;if(x===-1&&z===1)return 1;return 99;};// ========== D FACE ========== \n// y === -1, have a D sticker\nconst getDIndex=cubie=>{const[x,_,z]=cubie.position;// TODO: Decide how you'd like to label D's top-left => 0, top-right => 1, etc.\n// For instance:\n// if (x=-1,z=-1) => 0, (x=1,z=-1) => 1, (x=-1,z=1) => 2, (x=1,z=1) => 3\n// or any arrangement that yields the correct â€œvisualâ€ order for D.\nif(x===-1&&z===-1)return 2;if(x===1&&z===-1)return 3;if(x===-1&&z===1)return 0;if(x===1&&z===1)return 1;return 99;};// ========== F FACE ==========\nconst getFIndex=cubie=>{const[x,y,z]=cubie.position;// y is your vertical axis, x is left-right, z=1 for front\n// Decide which coordinate combos map to top-left => 0, top-right => 1, etc.\n// Example:\n// if (y=1, x=-1) => 0, (y=1, x=1) => 1, (y=-1, x=-1) => 2, (y=-1, x=1) => 3\n// So you end up with top row = y=1, bottom row = y=-1, left col = x=-1, right col = x=1\nif(y===1&&x===-1)return 0;if(y===1&&x===1)return 1;if(y===-1&&x===-1)return 2;if(y===-1&&x===1)return 3;return 99;};// ========== B FACE ==========\nconst getBIndex=cubie=>{const[x,y,z]=cubie.position;// Similar logic for the back face (z=-1).\n// If you want top-left => y=1,x=1 => 0, etc., fill it in:\nif(y===1&&x===1)return 0;if(y===1&&x===-1)return 1;if(y===-1&&x===1)return 2;if(y===-1&&x===-1)return 3;return 99;};// ========== L FACE ==========\nconst getLIndex=cubie=>{const[x,y,z]=cubie.position;// x = -1 for left\n// Decide top-left => (?), top-right => (?), bottom-left => (?), etc.\n// Possibly y=1 => top, z=-1 => left, etc.\nif(y===1&&z===1)return 1;if(y===1&&z===-1)return 0;if(y===-1&&z===1)return 3;if(y===-1&&z===-1)return 2;return 99;};// ========== R FACE ==========\nconst getRIndex=cubie=>{const[x,y,z]=cubie.position;// x=+1 for right\n// Fill in your top-left -> index0, top-right -> index1, etc.\nif(y===1&&z===-1)return 1;if(y===1&&z===1)return 0;if(y===-1&&z===-1)return 3;if(y===-1&&z===1)return 2;return 99;};// The main function to get stickers for each face:\nconst getFaceStickers=face=>{let filtered=[];switch(face){case\"U\":{filtered=cubeState.filter(c=>c.position[1]===1&&c.colors.U);filtered.sort((a,b)=>getUIndex(a)-getUIndex(b));return filtered.map(c=>getColorLetter(c.colors.U)).join(\"\");}case\"D\":{filtered=cubeState.filter(c=>c.position[1]===-1&&c.colors.D);filtered.sort((a,b)=>getDIndex(a)-getDIndex(b));return filtered.map(c=>getColorLetter(c.colors.D)).join(\"\");}case\"F\":{filtered=cubeState.filter(c=>c.position[2]===1&&c.colors.F);filtered.sort((a,b)=>getFIndex(a)-getFIndex(b));return filtered.map(c=>getColorLetter(c.colors.F)).join(\"\");}case\"B\":{filtered=cubeState.filter(c=>c.position[2]===-1&&c.colors.B);filtered.sort((a,b)=>getBIndex(a)-getBIndex(b));return filtered.map(c=>getColorLetter(c.colors.B)).join(\"\");}case\"L\":{filtered=cubeState.filter(c=>c.position[0]===-1&&c.colors.L);filtered.sort((a,b)=>getLIndex(a)-getLIndex(b));return filtered.map(c=>getColorLetter(c.colors.L)).join(\"\");}case\"R\":{filtered=cubeState.filter(c=>c.position[0]===1&&c.colors.R);filtered.sort((a,b)=>getRIndex(a)-getRIndex(b));return filtered.map(c=>getColorLetter(c.colors.R)).join(\"\");}default:return\"\";}};// Flatten in the face order your solver expects\nconst faceOrder=[\"U\",\"D\",\"F\",\"B\",\"R\",\"L\"];return faceOrder.map(face=>getFaceStickers(face)).join(\"\");};// const checkSymmetryAndSolve = async () => {\n//   // 1) Flatten the userâ€™s current cube state\n//   console.log(\"Cube state original format - Before update:\" , cubeState);\n//   const cubeString = flattenCubeStateByPosition(cubeState);\n//   console.log(\"Flattened Cube String:\", cubeString);\n//   try {\n//     // 2) Call your /find_symmetry endpoint first\n//     const res = await fetch(`${API_BASE_URL}/find_symmetry`, {\n//       method: \"POST\",\n//       headers: { \"Content-Type\": \"application/json\" },\n//       body: JSON.stringify({ cube_data: cubeString }),\n//     });\n//     const data = await res.json();\n//     if (!data.found) {\n//       console.log(\"No matching or symmetrical version found. Cannot solve.\");\n//       return; // or show a UI error\n//     }\n//     // If found == true\n//     if (data.state !== cubeString) {\n//       // Means we have a symmetrical match that differs from the user's state\n//       console.log(\"Server suggests symmetrical reorientation:\", data.state);\n//       // 3) Reorient the cube to that symmetrical version\n//       reorientCubeFromString(data.state);\n//     }\n//     else {\n//       // If no reorientation is needed, we can still trigger the solver:\n//       setShouldSolve(true);\n//     }\n//   } catch (err) {\n//     console.error(\"Error checking symmetry:\", err);\n//   }\n// }\n//   // useEffect to call solver after state is updated\n// useEffect(() => {\n//   if (shouldSolve) {\n//     callSolveEndpoint(); // uses the *latest* cubeState\n//     setShouldSolve(false);\n//   }\n// }, [cubeState, shouldSolve]);\n// Example: callSolveEndpoint references your existing handleSolve logic\n// const callSolveEndpoint = async () => {\n//   console.log(\"Cube state original format - after update:\" , cubeState);\n//   const cubeString = flattenCubeStateByPosition(cubeState);\n//   //const finalString = flattenCubeStateByPosition(cubeState);\n//   // the existing logic from handleSolve\n//   console.log(\"Cube state string - after upadate: \", cubeString);\n//   try {\n//     const response = await fetch(`${API_BASE_URL}/solve`, {\n//       method: \"POST\",\n//       headers: { \"Content-Type\": \"application/json\" },\n//       body: JSON.stringify({ cube_data: cubeString }),\n//     });\n//     const data = await response.json();\n//     if (!data) {\n//       console.log(\"no matching solution found\");\n//       return;\n//     }\n//     guideUserThroughSolution(data.solution);\n//   } catch (error) {\n//     console.error(\"Error solving:\", error);\n//   }\n// };\nfunction createBlankCubeState(){return[{id:\"UBL\",position:[-1,1,-1],colors:{}},{id:\"UBR\",position:[1,1,-1],colors:{}},{id:\"UFL\",position:[-1,1,1],colors:{}},{id:\"UFR\",position:[1,1,1],colors:{}},{id:\"DBL\",position:[-1,-1,-1],colors:{}},{id:\"DBR\",position:[1,-1,-1],colors:{}},{id:\"DFL\",position:[-1,-1,1],colors:{}},{id:\"DFR\",position:[1,-1,1],colors:{}}];}function reorientCubeFromString(cubeString){// We'll parse 24 characters in blocks of 4 for U,D,F,B,R,L\n// For each block, we figure out which cubies get which face color\nconst faceOrder=[\"U\",\"D\",\"F\",\"B\",\"R\",\"L\"];// A helper to convert a single letter like 'B' or 'O' back to e.g. \"blue\" or \"orange\"\nconst colorMapReverse={\"W\":\"white\",\"Y\":\"yellow\",\"B\":\"blue\",\"G\":\"green\",\"R\":\"red\",\"O\":\"orange\"};// 1) Create a blank 8-cubie array\nlet newState=createBlankCubeState();// 2) Define the â€œindex â†’ coordinateâ€ for each face\nconst getUCoordinateByIndex=i=>{// Inverse of your getUIndex. \nswitch(i){case 2:return[1,1,-1];// x=1,z=-1\ncase 3:return[-1,1,-1];// x=-1,z=-1\ncase 0:return[1,1,1];// x=1,z=1\ncase 1:return[-1,1,1];// x=-1,z=1\ndefault:return\" \";}};const getDCoordinateByIndex=i=>{switch(i){case 2:return[-1,-1,-1];case 3:return[1,-1,-1];case 0:return[-1,-1,1];case 1:return[1,-1,1];default:return\" \";}};const getFCoordinateByIndex=i=>{switch(i){case 0:return[-1,1,1];case 1:return[1,1,1];case 2:return[-1,-1,1];case 3:return[1,-1,1];default:return\" \";}};const getBCoordinateByIndex=i=>{switch(i){case 0:return[1,1,-1];case 1:return[-1,1,-1];case 2:return[1,-1,-1];case 3:return[-1,-1,-1];default:return\" \";}};const getLCoordinateByIndex=i=>{switch(i){case 1:return[-1,1,1];case 0:return[-1,1,-1];case 3:return[-1,-1,1];case 2:return[-1,-1,-1];default:return\" \";}};const getRCoordinateByIndex=i=>{switch(i){case 1:return[1,1,-1];case 0:return[1,1,1];case 3:return[1,-1,-1];case 2:return[1,-1,1];default:return\" \";}};// Similarly define getFCoordinateByIndex, getBCoordinateByIndex, etc...\n// matching how you set up getFIndex, getBIndex, etc.\n// 3) A helper that finds the cubie in newState that matches a coordinate\nfunction findCubieByPosition(x,y,z){return newState.find(c=>c.position[0]===x&&c.position[1]===y&&c.position[2]===z);}// 4) Parse the cubeString in 6 chunks of 4\nlet offset=0;for(let face of faceOrder){const faceChars=cubeString.slice(offset,offset+4);// next 4 letters\noffset+=4;for(let i=0;i<4;i++){const letter=faceChars[i];// e.g. 'B', 'O', 'W'\nconst colorString=colorMapReverse[letter]||\"unknown\";let xyz;if(face===\"U\"){xyz=getUCoordinateByIndex(i);}else if(face===\"D\"){xyz=getDCoordinateByIndex(i);}else if(face===\"F\"){xyz=getFCoordinateByIndex(i);}else if(face===\"B\"){xyz=getBCoordinateByIndex(i);}else if(face===\"R\"){xyz=getRCoordinateByIndex(i);}else if(face===\"L\"){xyz=getLCoordinateByIndex(i);}const[x,y,z]=xyz;// find the matching cubie\nconst cubie=findCubieByPosition(x,y,z);if(cubie){cubie.colors[face]=colorString;}}}// fill in newState\nsetCubeState(newState);// Also set a flag\n//setShouldSolve(true);\n}// 1) \"Find Solution\" button\nconst handleFindSolution=async()=>{const cubeString=flattenCubeStateByPosition(cubeState);try{// Check for symmetry\nconst symmetryRes=await fetch(`${API_BASE_URL}/find_symmetry`,{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify({cube_data:cubeString})});const symmetryData=await symmetryRes.json();if(!symmetryData.found){console.log(\"No symmetrical version found. Can't solve.\");setSolutionSteps(null);return;}// If we got a symmetrical match, reorient the cube\nif(symmetryData.state!==cubeString){reorientCubeFromString(symmetryData.state);console.log(\"notice: cube switch to identical symmetic state - adapt your cube with this symmetrica state\");}// Now request the solution steps from /solve\nconst solveRes=await fetch(`${API_BASE_URL}/solve`,{method:\"POST\",headers:{\"Content-Type\":\"application/json\"},body:JSON.stringify({cube_data:symmetryData.state})});const solveData=await solveRes.json();if(!(solveData!==null&&solveData!==void 0&&solveData.solution)){console.log(\"No solution returned.\");setSolutionSteps(null);return;}// Store the solution steps in state\nsetSolutionSteps(solveData.solution);console.log(\"Solution steps are ready. Click 'Guide Me' to start solving.\");}catch(err){console.error(\"Error finding or solving:\",err);}};// 2) \"Guide Me\" button\nconst handleGuideMe=()=>{if(!solutionSteps||solutionSteps.length===0){console.log(\"No solution steps. Click 'Find Solution' first.\");return;}// Start from the first move\nsetCurrentStepIndex(0);showManualStep(0);};// const guideUserThroughSolution = async (solutionMoves) => {\n//   for (const layer of solutionMoves) {\n//     if (layer === \"Congratulations!\") {\n//       console.log(\"Done!\");\n//       return;\n//     }\n//     let direction = 90;\n//     if (layer === \"B\" || layer === \"L\") {\n//       direction = -90;\n//     }\n//     // Show guidance with an arrow\n//     showArrowOnFace(layer, direction);\n//     // Wait before animating the move\n//     await delay(1000);  // 1-second pause before executing the move\n//     // Perform the rotation (animate and update state)\n//     rotateLayerCubies(layer, direction);\n//     // Remove the arrow after the move\n//     removeArrowFromFace(layer);\n//     // Wait before moving to the next step\n//     await delay(1000);\n//   }\n//   // Final success message\n//   showSuccessMessage();\n// };\nconst showManualStep=index=>{// If weâ€™re beyond the last move, show success\nif(index>=solutionSteps.length){showSuccessMessage();return;}const layer=solutionSteps[index];// If it's some special marker like \"Congratulations!\"\nif(layer===\"Congratulations!\"){showSuccessMessage();return;}// Determine arrow direction\nlet direction=90;if(layer===\"B\"||layer===\"L\"){direction=-90;}// Display the arrow on the correct face\nshowArrowsOnLayer(layer,direction);// Now we wait for the user to rotate manually...\n// The user will click \"Next\" or some UI button once theyâ€™ve done the move\n};const handleUserRotationDone=()=>{// Remove the arrow from the current face\nconst layer=solutionSteps[currentStepIndex];removeArrowsFromLayer(layer);// Move on to the next step\nconst nextIndex=currentStepIndex+1;setCurrentStepIndex(nextIndex);showManualStep(nextIndex);};faceElements.forEach(face=>{// Create the arrow element\nconst arrow=document.createElement(\"div\");arrow.classList.add(\"rotation-arrow\");arrow.classList.add(`rotation-arrow-${layer.toLowerCase()}`);// <--- add this line\n// Choose a symbol for clockwise vs. counterclockwise\narrow.innerHTML=direction>0?\"â†»\":\"â†º\";// Append the arrow to the face\nface.appendChild(arrow);});// Remove arrows from every face in that layer\nconst removeArrowsFromLayer=layer=>{const faceElements=document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);faceElements.forEach(face=>{const arrow=face.querySelector(\".rotation-arrow\");if(arrow)arrow.remove();});};const showSuccessMessage=()=>{const messageBox=document.createElement(\"div\");messageBox.classList.add(\"success-message\");messageBox.innerText=\"ðŸŽ‰ Cube Solved!\";document.body.appendChild(messageBox);setTimeout(()=>{messageBox.remove();// Remove after 3 seconds\n},3000);};const delay=ms=>new Promise(resolve=>setTimeout(resolve,ms));// --- RENDERING ---\nconst renderCubies=()=>cubeState.map(cubie=>{const{id,position,colors}=cubie;const[cx,cy,cz]=position;return/*#__PURE__*/_jsx(\"div\",{className:\"cubie\",\"data-x\":cx// So we can read them on click\n,\"data-y\":cy,\"data-z\":cz,style:{position:\"absolute\",width:\"88px\",height:\"88px\",transform:`translate3d(${cx*45}px, ${-cy*45}px, ${cz*45}px)`,transformStyle:\"preserve-3d\"},children:Object.entries(colors).map(_ref=>{let[face,color]=_ref;return/*#__PURE__*/_jsx(\"div\",{className:\"cubie-face\",\"data-face\":face// e.g., \"U\", \"D\", \"F\", etc.\n,style:{position:\"absolute\",width:\"80px\",height:\"80px\",border:\"8px solid black\",backgroundColor:color,transform:getFaceTransform(face),cursor:\"pointer\"}},face);})},id);});// Places each face in the correct orientation\nconst getFaceTransform=face=>{switch(face){case\"U\":return\"rotateX(90deg) translateZ(45px)\";case\"D\":return\"rotateX(-90deg) translateZ(45px)\";case\"F\":return\"translateZ(45px)\";case\"B\":return\"rotateY(180deg) translateZ(45px)\";case\"L\":return\"rotateY(-90deg) translateZ(45px)\";case\"R\":return\"rotateY(90deg) translateZ(45px)\";default:return\"\";}};return/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"button\",{onClick:scrambleCube,children:\"Scramble\"}),\" \",/*#__PURE__*/_jsx(\"button\",{onClick:handleFindSolution,children:\"Find Solution\"}),/*#__PURE__*/_jsx(\"button\",{onClick:handleGuideMe,children:\"Guide Me\"}),/*#__PURE__*/_jsx(\"button\",{onClick:handleUserRotationDone,children:\"Next Move\"}),/*#__PURE__*/_jsx(\"div\",{className:\"cube-container\",onMouseDown:handleMouseDown,onMouseMove:handleMouseMove,onMouseUp:handleMouseUp,onMouseLeave:handleMouseLeave,style:{width:\"700px\",height:\"700px\",position:\"relative\"},children:/*#__PURE__*/_jsx(\"div\",{className:\"cube\",style:{transform:`rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`,transformStyle:\"preserve-3d\",position:\"absolute\",width:\"100px\",height:\"100px\"},children:renderCubies()})})]});};export default Cube;// Export the Cube component","map":{"version":3,"names":["React","useState","useEffect","API_BASE_URL","jsx","_jsx","jsxs","_jsxs","initialCubeState","id","position","colors","U","B","L","R","F","D","getLayerFromFaceAndPosition","face","x","y","z","parseInt","Cube","cubeState","setCubeState","shouldSolve","setShouldSolve","rotation","setRotation","isDragging","setIsDragging","dragStart","setDragStart","selectedLayer","setSelectedLayer","solutionSteps","setSolutionSteps","currentStepIndex","setCurrentStepIndex","handleMouseDown","event","faceElement","target","closest","dataset","cubieEl","layer","clientX","clientY","handleMouseMove","MAX_ROTATION_X","MIN_ROTATION_X","deltaX","deltaY","prev","newX","newY","Math","max","min","abs","direction","rotateLayerCubies","handleMouseUp","handleMouseLeave","prevState","newState","axisIndex","axisValue","affectedCubies","filter","c","updateColor","value","hasOwnProperty","undefined","rotateCubie","cubie","newPosition","newColors","reassignFace","oldFace","newFace","updated","forEach","map","scrambleCube","SCRAMBLE_LENGTH","faces","directions","delay","ms","Promise","resolve","setTimeout","i","randomFace","floor","random","length","randomDir","flattenCubeStateByPosition","getColorLetter","color","colorMap","white","yellow","blue","green","red","orange","getUIndex","_","getDIndex","getFIndex","getBIndex","getLIndex","getRIndex","getFaceStickers","filtered","sort","a","b","join","faceOrder","createBlankCubeState","reorientCubeFromString","cubeString","colorMapReverse","getUCoordinateByIndex","getDCoordinateByIndex","getFCoordinateByIndex","getBCoordinateByIndex","getLCoordinateByIndex","getRCoordinateByIndex","findCubieByPosition","find","offset","faceChars","slice","letter","colorString","xyz","handleFindSolution","symmetryRes","fetch","method","headers","body","JSON","stringify","cube_data","symmetryData","json","found","console","log","state","solveRes","solveData","solution","err","error","handleGuideMe","showManualStep","index","showSuccessMessage","showArrowsOnLayer","handleUserRotationDone","removeArrowsFromLayer","nextIndex","faceElements","arrow","document","createElement","classList","add","toLowerCase","innerHTML","appendChild","querySelectorAll","querySelector","remove","messageBox","innerText","renderCubies","cx","cy","cz","className","style","width","height","transform","transformStyle","children","Object","entries","_ref","border","backgroundColor","getFaceTransform","cursor","onClick","onMouseDown","onMouseMove","onMouseUp","onMouseLeave"],"sources":["/home/gal98/projects/pocket-cube-solver/frontend/src/components/Cube.js"],"sourcesContent":["/* eslint-disable default-case */\nimport React, { useState, useEffect } from \"react\";\nimport \"./Cube.css\";\nimport API_BASE_URL from \"../config\";\n\n// const defaultColors = {\n//   U: \"blue\",   // Up\n//   D: \"green\",  // Down\n//   F: \"orange\", // Front\n//   B: \"red\",    // Back\n//   L: \"white\",  // Left\n//   R: \"yellow\", // Right\n// };\n\n\nconst initialCubeState = [\n  {\n    id: \"UBL\",\n    position: [-1, 1, -1],\n    colors: { U: \"blue\", B: \"red\", L: \"yellow\" },\n  },\n  {\n    id: \"UBR\",\n    position: [1, 1, -1],\n    colors: { U: \"blue\", B: \"red\", R: \"white\" },\n  },\n  {\n    id: \"UFL\",\n    position: [-1, 1, 1],\n    colors: { U: \"blue\", F: \"orange\", L: \"yellow\" },\n  },\n  {\n    id: \"UFR\",\n    position: [1, 1, 1],\n    colors: { U: \"blue\", F: \"orange\", R: \"white\" },\n  },\n  {\n    id: \"DBL\",\n    position: [-1, -1, -1],\n    colors: { D: \"green\", B: \"red\", L: \"yellow\" },\n  },\n  {\n    id: \"DBR\",\n    position: [1, -1, -1],\n    colors: { D: \"green\", B: \"red\", R: \"white\" },\n  },\n  {\n    id: \"DFL\",\n    position: [-1, -1, 1],\n    colors: { D: \"green\", F: \"orange\", L: \"yellow\" },\n  },\n  {\n    id: \"DFR\",\n    position: [1, -1, 1],\n    colors: { D: \"green\", F: \"orange\", R: \"white\" },\n  },\n];\n\n\n// Helper that decides exactly which layer to rotate, given the face clicked\n// and the (x,y,z) position of that cubie.\nfunction getLayerFromFaceAndPosition(face, x, y, z) {\n  // Convert to integers, since dataset attributes come as strings\n  x = parseInt(x, 10);\n  y = parseInt(y, 10);\n  z = parseInt(z, 10);\n\n  switch (face) {\n    case \"U\":\n      // Only rotate top layer if y=1\n      return y === 1 ? \"U\" : null;\n\n    case \"D\":\n      // Only rotate bottom layer if y=-1\n      return y === -1 ? \"D\" : null;\n\n    case \"F\":\n      // Only rotate front layer if z=1\n      return z === 1 ? \"F\" : null;\n\n    case \"B\":\n      // Only rotate back layer if z=-1\n      return z === -1 ? \"B\" : null;\n\n    case \"R\":\n      // Only rotate right layer if x=1\n      return x === 1 ? \"R\" : null;\n\n    case \"L\":\n      // Only rotate left layer if x=-1\n      return x === -1 ? \"L\" : null;\n\n    default:\n      return null;\n  }\n}\n\nconst Cube = () => {\n  const [cubeState, setCubeState] = useState(initialCubeState);\n  const [shouldSolve, setShouldSolve] = useState(false);\n  const [rotation, setRotation] = useState({ x: -30, y: 45 }); // Whole-cube rotation\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const [selectedLayer, setSelectedLayer] = useState(null);\n  const [solutionSteps, setSolutionSteps] = useState([]);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  \n\n  // --- MOUSE EVENTS ---\n  const handleMouseDown = (event) => {\n    // 1) Check if you clicked on a specific face via data-face\n    const faceElement = event.target.closest(\".cubie-face\");\n    if (faceElement) {\n      const face = faceElement.dataset.face; // e.g., \"U\", \"R\", ...\n      if (face) {\n        // Grab the parent .cubie to read its data-x, data-y, data-z\n        const cubieEl = faceElement.closest(\".cubie\");\n        if (cubieEl) {\n          const { x, y, z } = cubieEl.dataset;\n          // Figure out the *actual* layer to rotate, if any\n          const layer = getLayerFromFaceAndPosition(face, x, y, z);\n\n          if (layer) {\n            setSelectedLayer(layer);\n            setDragStart({ x: event.clientX, y: event.clientY });\n            return; // Skip rotating the whole cube\n          }\n        }\n      }\n    }\n\n    // 2) Otherwise, rotate the entire cube\n    setIsDragging(true);\n    setDragStart({ x: event.clientX, y: event.clientY });\n  };\n\n  const handleMouseMove = (event) => {\n    // A) If dragging the whole cube\n    const MAX_ROTATION_X = 90;  // Maximum x rotation\n    const MIN_ROTATION_X = -90; // Minimum x rotation\n    \n    if (isDragging) {\n      const deltaX = event.clientX - dragStart.x;\n      const deltaY = event.clientY - dragStart.y;\n    \n      // Update x with the deltaY, but clamp it between MIN_ROTATION_X and MAX_ROTATION_X\n      setRotation((prev) => {\n        const newX = prev.x - deltaY * 0.3;\n        const newY = prev.y + deltaX * 0.3;\n    \n        return {\n          x: Math.max(MIN_ROTATION_X, Math.min(newX, MAX_ROTATION_X)), // Clamp x\n          y: newY,\n        };\n      });\n    \n      setDragStart({ x: event.clientX, y: event.clientY });\n    }\n    \n\n    // B) If dragging a face to rotate that layer\n    if (selectedLayer) {\n      const deltaX = event.clientX - dragStart.x;\n      if (Math.abs(deltaX) > 30) {\n        const direction = deltaX > 0 ? 90 : -90;\n        rotateLayerCubies(selectedLayer, direction);\n        setSelectedLayer(null); // Prevent repeated rotations on same drag\n      }\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n\n  const handleMouseLeave = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n\n  const rotateLayerCubies = (layer, direction) => {\n    setCubeState((prevState) => {\n      const newState = [...prevState];\n      let axisIndex, axisValue;\n      switch (layer) {\n        case \"U\":\n          axisIndex = 1; // y\n          axisValue = 1;\n          break;\n        case \"D\":\n          axisIndex = 1;\n          axisValue = -1;\n          break;\n        case \"F\":\n          axisIndex = 2; // z\n          axisValue = 1;\n          break;\n        case \"B\":\n          axisIndex = 2;\n          axisValue = -1;\n          break;\n        case \"R\":\n          axisIndex = 0; // x\n          axisValue = 1;\n          break;\n        case \"L\":\n          axisIndex = 0;\n          axisValue = -1;\n          break;\n        default:\n          return newState;\n      }\n      const affectedCubies = newState.filter(\n        (c) => c.position[axisIndex] === axisValue\n      );\n  \n      // Helper to update a sticker only if it exists.\n      const updateColor = (colors, target, value) => {\n        return colors.hasOwnProperty(target) ? value : undefined;\n      };\n  \n      const rotateCubie = (cubie) => {\n        const { position, colors } = cubie;\n        const [x, y, z] = position;\n        let newPosition = [...position];\n        let newColors = { ...colors };\n      \n        // Helper function: assign oldFace to newFace if oldFace existed, then delete oldFace\n        const reassignFace = (oldFace, newFace) => {\n          if (colors[oldFace]) {\n            newColors[newFace] = colors[oldFace];\n            //delete newColors[oldFace];\n          }\n        };\n      \n        switch (layer) {\n          case \"U\":\n            if (direction > 0) {\n              // +90 around U\n              newPosition = [z, y, -x];\n              // Keep U face\n              if (colors.U) newColors.U = colors.U;\n      \n              //F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"R\", \"B\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"L\", \"F\");\n            } else {\n              // -90 around U\n              newPosition = [-z, y, x];\n              if (colors.U) newColors.U = colors.U;\n      \n              // F->L, L->B, B->R, R->F (the reverse mapping)\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"L\", \"B\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"R\", \"F\");\n            }\n            break;\n      \n          case \"D\":\n            if (direction > 0) {\n              newPosition = [z, y, -x];\n              if (colors.D) newColors.D = colors.D;\n      \n              // F->L, L->B, B->R, R->F (for example)\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"L\", \"F\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"R\", \"B\");\n\n\n\n            } else {\n              newPosition = [-z, y, x];\n              if (colors.D) newColors.D = colors.D;\n      \n              // F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"R\", \"F\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"L\", \"B\");\n            }\n            break;\n      \n          case \"F\":\n            if (direction > 0) {\n              newPosition = [y, -x, z];\n              if (colors.F) newColors.F = colors.F;\n      \n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            } else {\n              newPosition = [-y, x, z];\n              if (colors.F) newColors.F = colors.F;\n      \n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            }\n            break;\n      \n          case \"B\":\n            if (direction > 0) {\n              newPosition = [-y, x, z];\n              if (colors.B) newColors.B = colors.B;\n      \n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            } else {\n              newPosition = [y, -x, z];\n              if (colors.B) newColors.B = colors.B;\n      \n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            }\n            break;\n      \n          case \"R\":\n            if (direction > 0) {\n              newPosition = [x, z, -y];\n              if (colors.R) newColors.R = colors.R;\n      \n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            } else {\n              newPosition = [x, -z, y];\n              if (colors.R) newColors.R = colors.R;\n      \n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            }\n            break;\n      \n          case \"L\":\n            if (direction > 0) {\n              newPosition = [x, -z, y];\n              if (colors.L) newColors.L = colors.L;\n      \n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            } else {\n              newPosition = [x, z, -y];\n              if (colors.L) newColors.L = colors.L;\n      \n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            }\n            break;\n        }\n      \n        return { ...cubie, position: newPosition, colors: newColors };\n      };\n      \n  \n      const updated = {};\n      affectedCubies.forEach((cubie) => {\n        updated[cubie.id] = rotateCubie(cubie);\n      });\n  \n      return newState.map((c) => updated[c.id] || c);\n    });\n  };\n  \n  const scrambleCube = async () => {\n    // Decide how many random moves you want:\n    const SCRAMBLE_LENGTH = 15; // or 20, etc.\n\n    const faces = [\"U\", \"D\", \"L\", \"R\", \"F\", \"B\"];\n    const directions = [90, -90]; // clockwise or counterclockwise\n\n    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms)); // Delay function\n\n    for (let i = 0; i < SCRAMBLE_LENGTH; i++) {\n      const randomFace = faces[Math.floor(Math.random() * faces.length)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      \n      // rotateLayerCubies is your existing method to do 90Â° turns\n      rotateLayerCubies(randomFace, randomDir);\n\n      // Wait for a timeout before the next move (e.g., 300ms between moves)\n      await delay(300); \n    }\n  };\n\n  const flattenCubeStateByPosition = (cubeState) => {\n    // Convert color strings to single-letter codes\n    const getColorLetter = (color) => {\n      const colorMap = {\n        white: \"W\",\n        yellow: \"Y\",\n        blue: \"B\",\n        green: \"G\",\n        red: \"R\",\n        orange: \"O\",\n      };\n      return colorMap[color] || \"?\";\n    };\n\n    // ========== U FACE ========== \n    // y === 1, have a U sticker\n    const getUIndex = (cubie) => {\n      const [x, _, z] = cubie.position;\n      // Example: top-left => 0, top-right => 1, bottom-left => 2, bottom-right => 3\n      // Fill in the coordinates that physically match each slot.\n      // (Just like your existing getUIndex)\n      if (x ===  1 && z === -1) return 2;  \n      if (x === -1 && z === -1) return 3;\n      if (x ===  1 && z ===  1) return 0;\n      if (x === -1 && z ===  1) return 1;\n      return 99; \n    };\n\n    // ========== D FACE ========== \n    // y === -1, have a D sticker\n    const getDIndex = (cubie) => {\n      const [x, _, z] = cubie.position;\n      // TODO: Decide how you'd like to label D's top-left => 0, top-right => 1, etc.\n      // For instance:\n      // if (x=-1,z=-1) => 0, (x=1,z=-1) => 1, (x=-1,z=1) => 2, (x=1,z=1) => 3\n      // or any arrangement that yields the correct â€œvisualâ€ order for D.\n      if (x === -1 && z === -1) return 2;\n      if (x ===  1 && z === -1) return 3;\n      if (x === -1 && z ===  1) return 0;\n      if (x ===  1 && z ===  1) return 1;\n      return 99;\n    };\n\n    // ========== F FACE ==========\n    const getFIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // y is your vertical axis, x is left-right, z=1 for front\n      // Decide which coordinate combos map to top-left => 0, top-right => 1, etc.\n      // Example:\n      // if (y=1, x=-1) => 0, (y=1, x=1) => 1, (y=-1, x=-1) => 2, (y=-1, x=1) => 3\n      // So you end up with top row = y=1, bottom row = y=-1, left col = x=-1, right col = x=1\n      if (y ===  1 && x === -1) return 0;\n      if (y ===  1 && x ===  1) return 1;\n      if (y === -1 && x === -1) return 2;\n      if (y === -1 && x ===  1) return 3;\n      return 99;\n    };\n\n    // ========== B FACE ==========\n    const getBIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // Similar logic for the back face (z=-1).\n      // If you want top-left => y=1,x=1 => 0, etc., fill it in:\n      if (y ===  1 && x ===  1) return 0;\n      if (y ===  1 && x === -1) return 1;\n      if (y === -1 && x ===  1) return 2;\n      if (y === -1 && x === -1) return 3;\n      return 99;\n    };\n\n    // ========== L FACE ==========\n    const getLIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // x = -1 for left\n      // Decide top-left => (?), top-right => (?), bottom-left => (?), etc.\n      // Possibly y=1 => top, z=-1 => left, etc.\n      if (y === 1 && z === 1) return 1;\n      if (y === 1 && z === -1) return 0;\n      if (y === -1 && z === 1) return 3;\n      if (y === -1 && z === -1) return 2;\n      return 99;\n    };\n\n    // ========== R FACE ==========\n    const getRIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // x=+1 for right\n      // Fill in your top-left -> index0, top-right -> index1, etc.\n      if (y ===  1 && z === -1) return 1;\n      if (y ===  1 && z ===  1)  return 0;\n      if (y === -1 && z === -1) return 3;\n      if (y === -1 && z ===  1) return 2;\n      return 99;\n    };\n\n    // The main function to get stickers for each face:\n    const getFaceStickers = (face) => {\n      let filtered = [];\n      switch (face) {\n        case \"U\": {\n          filtered = cubeState.filter(c => c.position[1] === 1 && c.colors.U);\n          filtered.sort((a, b) => getUIndex(a) - getUIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.U)).join(\"\");\n        }\n        case \"D\": {\n          filtered = cubeState.filter(c => c.position[1] === -1 && c.colors.D);\n          filtered.sort((a, b) => getDIndex(a) - getDIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.D)).join(\"\");\n        }\n        case \"F\": {\n          filtered = cubeState.filter(c => c.position[2] === 1 && c.colors.F);\n          filtered.sort((a, b) => getFIndex(a) - getFIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.F)).join(\"\");\n        }\n        case \"B\": {\n          filtered = cubeState.filter(c => c.position[2] === -1 && c.colors.B);\n          filtered.sort((a, b) => getBIndex(a) - getBIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.B)).join(\"\");\n        }\n        case \"L\": {\n          filtered = cubeState.filter(c => c.position[0] === -1 && c.colors.L);\n          filtered.sort((a, b) => getLIndex(a) - getLIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.L)).join(\"\");\n        }\n        case \"R\": {\n          filtered = cubeState.filter(c => c.position[0] === 1 && c.colors.R);\n          filtered.sort((a, b) => getRIndex(a) - getRIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.R)).join(\"\");\n        }\n        default:\n          return \"\";\n      }\n    };\n\n    // Flatten in the face order your solver expects\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    return faceOrder.map(face => getFaceStickers(face)).join(\"\");\n  };\n\n\n\n\n  // const checkSymmetryAndSolve = async () => {\n  //   // 1) Flatten the userâ€™s current cube state\n  //   console.log(\"Cube state original format - Before update:\" , cubeState);\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   console.log(\"Flattened Cube String:\", cubeString);\n\n  //   try {\n  //     // 2) Call your /find_symmetry endpoint first\n  //     const res = await fetch(`${API_BASE_URL}/find_symmetry`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await res.json();\n      \n  //     if (!data.found) {\n  //       console.log(\"No matching or symmetrical version found. Cannot solve.\");\n  //       return; // or show a UI error\n  //     }\n      \n  //     // If found == true\n  //     if (data.state !== cubeString) {\n  //       // Means we have a symmetrical match that differs from the user's state\n  //       console.log(\"Server suggests symmetrical reorientation:\", data.state);\n  //       // 3) Reorient the cube to that symmetrical version\n  //       reorientCubeFromString(data.state);\n  //     }\n\n  //     else {\n  //       // If no reorientation is needed, we can still trigger the solver:\n  //       setShouldSolve(true);\n  //     }\n\n      \n  //   } catch (err) {\n  //     console.error(\"Error checking symmetry:\", err);\n  //   }\n  // }\n\n  //   // useEffect to call solver after state is updated\n  // useEffect(() => {\n  //   if (shouldSolve) {\n  //     callSolveEndpoint(); // uses the *latest* cubeState\n  //     setShouldSolve(false);\n  //   }\n  // }, [cubeState, shouldSolve]);\n  \n  // Example: callSolveEndpoint references your existing handleSolve logic\n  // const callSolveEndpoint = async () => {\n  //   console.log(\"Cube state original format - after update:\" , cubeState);\n\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   //const finalString = flattenCubeStateByPosition(cubeState);\n  //   // the existing logic from handleSolve\n  //   console.log(\"Cube state string - after upadate: \", cubeString);\n\n  //   try {\n  //     const response = await fetch(`${API_BASE_URL}/solve`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await response.json();\n  //     if (!data) {\n  //       console.log(\"no matching solution found\");\n  //       return;\n  //     }\n  //     guideUserThroughSolution(data.solution);\n  //   } catch (error) {\n  //     console.error(\"Error solving:\", error);\n  //   }\n  // };\n  \n  \n  function createBlankCubeState() {\n    return [\n      {\n        id: \"UBL\",\n        position: [-1, 1, -1],\n        colors: {},\n      },\n      {\n        id: \"UBR\",\n        position: [1, 1, -1],\n        colors: {},\n      },\n      {\n        id: \"UFL\",\n        position: [-1, 1, 1],\n        colors: {},\n      },\n      {\n        id: \"UFR\",\n        position: [1, 1, 1],\n        colors: {},\n      },\n      {\n        id: \"DBL\",\n        position: [-1, -1, -1],\n        colors: {},\n      },\n      {\n        id: \"DBR\",\n        position: [1, -1, -1],\n        colors: {},\n      },\n      {\n        id: \"DFL\",\n        position: [-1, -1, 1],\n        colors: {},\n      },\n      {\n        id: \"DFR\",\n        position: [1, -1, 1],\n        colors: {},\n      },\n    ];\n  }\n  \n\n  function reorientCubeFromString(cubeString) {\n  // We'll parse 24 characters in blocks of 4 for U,D,F,B,R,L\n  // For each block, we figure out which cubies get which face color\n\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    // A helper to convert a single letter like 'B' or 'O' back to e.g. \"blue\" or \"orange\"\n    const colorMapReverse = {\n      \"W\": \"white\",\n      \"Y\": \"yellow\",\n      \"B\": \"blue\",\n      \"G\": \"green\",\n      \"R\": \"red\",\n      \"O\": \"orange\",\n    };\n\n    // 1) Create a blank 8-cubie array\n    let newState = createBlankCubeState();\n\n    // 2) Define the â€œindex â†’ coordinateâ€ for each face\n    const getUCoordinateByIndex = (i) => {\n      // Inverse of your getUIndex. \n      switch(i) {\n        case 2: return [1, 1, -1];   // x=1,z=-1\n        case 3: return [-1,1, -1];  // x=-1,z=-1\n        case 0: return [1, 1, 1];    // x=1,z=1\n        case 1: return [-1,1, 1];    // x=-1,z=1\n        default:\n          return \" \"\n      }\n    };\n\n    const getDCoordinateByIndex = (i) => {\n      switch(i) {\n        case 2: return [-1,-1,-1];\n        case 3: return [1, -1, -1];\n        case 0: return [-1,-1, 1];\n        case 1: return [1, -1, 1];\n        default:\n          return \" \"\n      }\n    };\n\n    const getFCoordinateByIndex = (i) => {\n      switch(i) {\n        case 0: return [-1,1,1];\n        case 1: return [1, 1,1];\n        case 2: return [-1,-1,1];\n        case 3: return [1, -1,1];\n        default:\n          return \" \"\n      }\n    };\n\n    \n    const getBCoordinateByIndex = (i) => {\n      switch(i) {\n        case 0: return [1,1,-1];\n        case 1: return [-1, 1,-1];\n        case 2: return [1,-1,-1];\n        case 3: return [-1, -1,-1];\n        default:\n          return \" \"\n      }\n    };\n\n    const getLCoordinateByIndex = (i) => {\n      switch(i) {\n        case 1: return [-1,1,1];\n        case 0: return [-1, 1,-1];\n        case 3: return [-1,-1,1];\n        case 2: return [-1, -1,-1];\n        default:\n          return \" \"\n      }\n    };\n\n    \n    const getRCoordinateByIndex = (i) => {\n      switch(i) {\n        case 1: return [1,1,-1];\n        case 0: return [1, 1,1];\n        case 3: return [1,-1,-1];\n        case 2: return [1, -1,1];\n        default:\n          return \" \"\n      }\n    };\n    // Similarly define getFCoordinateByIndex, getBCoordinateByIndex, etc...\n    // matching how you set up getFIndex, getBIndex, etc.\n\n    // 3) A helper that finds the cubie in newState that matches a coordinate\n    function findCubieByPosition(x, y, z) {\n      return newState.find(c => \n        c.position[0] === x &&\n        c.position[1] === y &&\n        c.position[2] === z\n      );\n    }\n\n    // 4) Parse the cubeString in 6 chunks of 4\n    let offset = 0;\n    for (let face of faceOrder) {\n      const faceChars = cubeString.slice(offset, offset+4); // next 4 letters\n      offset += 4;\n\n      for (let i = 0; i < 4; i++) {\n        const letter = faceChars[i];  // e.g. 'B', 'O', 'W'\n        const colorString = colorMapReverse[letter] || \"unknown\";\n\n        let xyz;\n        if (face === \"U\") {\n          xyz = getUCoordinateByIndex(i);\n        } else if (face === \"D\") {\n          xyz = getDCoordinateByIndex(i);\n        } \n        else if (face === \"F\") { xyz = getFCoordinateByIndex(i); }\n        else if (face === \"B\") { xyz = getBCoordinateByIndex(i); }\n        else if (face === \"R\") { xyz = getRCoordinateByIndex(i); }\n        else if (face === \"L\") { xyz = getLCoordinateByIndex(i); }\n\n        const [x,y,z] = xyz;\n        // find the matching cubie\n        const cubie = findCubieByPosition(x,y,z);\n        if (cubie) {\n          cubie.colors[face] = colorString;\n        }\n      }\n    }\n    // fill in newState\n    setCubeState(newState);\n\n    // Also set a flag\n    //setShouldSolve(true);\n  }\n\n  \n    // 1) \"Find Solution\" button\n    const handleFindSolution = async () => {\n      const cubeString = flattenCubeStateByPosition(cubeState);\n  \n      try {\n        // Check for symmetry\n        const symmetryRes = await fetch(`${API_BASE_URL}/find_symmetry`, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ cube_data: cubeString }),\n        });\n        const symmetryData = await symmetryRes.json();\n  \n        if (!symmetryData.found) {\n          console.log(\"No symmetrical version found. Can't solve.\");\n          setSolutionSteps(null);\n          return;\n        }\n  \n        // If we got a symmetrical match, reorient the cube\n        if (symmetryData.state !== cubeString) {\n          reorientCubeFromString(symmetryData.state);\n          console.log(\"notice: cube switch to identical symmetic state - adapt your cube with this symmetrica state\")\n        }\n  \n        // Now request the solution steps from /solve\n        const solveRes = await fetch(`${API_BASE_URL}/solve`, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ cube_data: symmetryData.state }),\n        });\n        const solveData = await solveRes.json();\n  \n        if (!solveData?.solution) {\n          console.log(\"No solution returned.\");\n          setSolutionSteps(null);\n          return;\n        }\n  \n        // Store the solution steps in state\n        setSolutionSteps(solveData.solution);\n        console.log(\"Solution steps are ready. Click 'Guide Me' to start solving.\");\n      } catch (err) {\n        console.error(\"Error finding or solving:\", err);\n      }\n    };\n  \n    // 2) \"Guide Me\" button\n    const handleGuideMe = () => {\n      if (!solutionSteps || solutionSteps.length === 0) {\n        console.log(\"No solution steps. Click 'Find Solution' first.\");\n        return;\n      }\n      // Start from the first move\n      setCurrentStepIndex(0);\n      showManualStep(0);\n    };\n    \n\n\n  // const guideUserThroughSolution = async (solutionMoves) => {\n  //   for (const layer of solutionMoves) {\n\n  //     if (layer === \"Congratulations!\") {\n  //       console.log(\"Done!\");\n  //       return;\n  //     }\n\n  //     let direction = 90;\n  //     if (layer === \"B\" || layer === \"L\") {\n  //       direction = -90;\n  //     }\n  //     // Show guidance with an arrow\n  //     showArrowOnFace(layer, direction);\n  \n  //     // Wait before animating the move\n  //     await delay(1000);  // 1-second pause before executing the move\n  \n  //     // Perform the rotation (animate and update state)\n  //     rotateLayerCubies(layer, direction);\n  \n  //     // Remove the arrow after the move\n  //     removeArrowFromFace(layer);\n  \n  //     // Wait before moving to the next step\n  //     await delay(1000);\n  //   }\n  \n  //   // Final success message\n  //   showSuccessMessage();\n  // };\n  \n\n  const showManualStep = (index) => {\n    // If weâ€™re beyond the last move, show success\n    if (index >= solutionSteps.length) {\n      showSuccessMessage();\n      return;\n    }\n  \n    const layer = solutionSteps[index];\n    // If it's some special marker like \"Congratulations!\"\n    if (layer === \"Congratulations!\") {\n      showSuccessMessage();\n      return;\n    }\n  \n    // Determine arrow direction\n    let direction = 90;\n    if (layer === \"B\" || layer === \"L\") {\n      direction = -90;\n    }\n  \n    // Display the arrow on the correct face\n    showArrowsOnLayer(layer, direction);\n  \n    // Now we wait for the user to rotate manually...\n    // The user will click \"Next\" or some UI button once theyâ€™ve done the move\n  };\n\n  const handleUserRotationDone = () => {\n    // Remove the arrow from the current face\n    const layer = solutionSteps[currentStepIndex];\n    removeArrowsFromLayer(layer);\n  \n    // Move on to the next step\n    const nextIndex = currentStepIndex + 1;\n    setCurrentStepIndex(nextIndex);\n    showManualStep(nextIndex);\n  };\n  \n  \n\n  faceElements.forEach((face) => {\n    // Create the arrow element\n    const arrow = document.createElement(\"div\");\n    arrow.classList.add(\"rotation-arrow\");\n    arrow.classList.add(`rotation-arrow-${layer.toLowerCase()}`); // <--- add this line\n  \n    // Choose a symbol for clockwise vs. counterclockwise\n    arrow.innerHTML = direction > 0 ? \"â†»\" : \"â†º\";\n  \n    // Append the arrow to the face\n    face.appendChild(arrow);\n  });\n  \n\n  // Remove arrows from every face in that layer\n  const removeArrowsFromLayer = (layer) => {\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n\n    faceElements.forEach((face) => {\n      const arrow = face.querySelector(\".rotation-arrow\");\n      if (arrow) arrow.remove();\n    });\n  };\n\n\n  const showSuccessMessage = () => {\n    const messageBox = document.createElement(\"div\");\n    messageBox.classList.add(\"success-message\");\n    messageBox.innerText = \"ðŸŽ‰ Cube Solved!\";\n    document.body.appendChild(messageBox);\n  \n    setTimeout(() => {\n      messageBox.remove(); // Remove after 3 seconds\n    }, 3000);\n  };\n  \n\n  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n\n  // --- RENDERING ---\n  const renderCubies = () =>\n    cubeState.map((cubie) => {\n      const { id, position, colors } = cubie;\n      const [cx, cy, cz] = position;\n\n      return (\n        <div\n          key={id}\n          className=\"cubie\"\n          data-x={cx}     // So we can read them on click\n          data-y={cy}\n          data-z={cz}\n          style={{\n            position: \"absolute\",\n            width: \"88px\",\n            height: \"88px\",\n            transform: `translate3d(${cx * 45}px, ${-cy * 45}px, ${cz * 45}px)`,\n            transformStyle: \"preserve-3d\",\n          }}\n        >\n          {Object.entries(colors).map(([face, color]) => (\n            <div\n              key={face}\n              className=\"cubie-face\"\n              data-face={face} // e.g., \"U\", \"D\", \"F\", etc.\n              style={{\n                position: \"absolute\",\n                width: \"80px\",\n                height: \"80px\",\n                border: \"8px solid black\",\n                backgroundColor: color,\n                transform: getFaceTransform(face),\n                cursor: \"pointer\",\n              }}\n            />\n          ))}\n        </div>\n      );\n    });\n\n  // Places each face in the correct orientation\n  const getFaceTransform = (face) => {\n    switch (face) {\n      case \"U\":\n        return \"rotateX(90deg) translateZ(45px)\";\n      case \"D\":\n        return \"rotateX(-90deg) translateZ(45px)\";\n      case \"F\":\n        return \"translateZ(45px)\";\n      case \"B\":\n        return \"rotateY(180deg) translateZ(45px)\";\n      case \"L\":\n        return \"rotateY(-90deg) translateZ(45px)\";\n      case \"R\":\n        return \"rotateY(90deg) translateZ(45px)\";\n      default:\n        return \"\";\n    }\n  };\n\n\n\n  return (\n    <div>\n      <button onClick={scrambleCube}>Scramble</button> {/* Add the scramble button here */}\n      <button onClick={handleFindSolution}>Find Solution</button>\n      <button onClick={handleGuideMe}>Guide Me</button>\n      <button onClick={handleUserRotationDone}>Next Move</button>\n      <div\n        className=\"cube-container\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseLeave}\n        style={{ width: \"700px\", height: \"700px\", position: \"relative\" }}\n      >\n        <div\n          className=\"cube\"\n          style={{\n            transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`,\n            transformStyle: \"preserve-3d\",\n            position: \"absolute\",\n            width: \"100px\",\n            height: \"100px\",\n          }}\n        >\n          {renderCubies()}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Cube;  // Export the Cube component\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}