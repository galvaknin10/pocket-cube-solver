{"ast":null,"code":"var _jsxFileName = \"/home/gal98/projects/pocket-cube-solver/frontend/src/components/Cube.js\",\n  _s = $RefreshSig$();\n/* eslint-disable default-case */\nimport React, { useState, useEffect } from \"react\";\nimport \"./Cube.css\";\nimport API_BASE_URL from \"../config\";\n\n// const defaultColors = {\n//   U: \"blue\",   // Up\n//   D: \"green\",  // Down\n//   F: \"orange\", // Front\n//   B: \"red\",    // Back\n//   L: \"white\",  // Left\n//   R: \"yellow\", // Right\n// };\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst initialCubeState = [{\n  id: \"UBL\",\n  position: [-1, 1, -1],\n  colors: {\n    U: \"blue\",\n    B: \"red\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"UBR\",\n  position: [1, 1, -1],\n  colors: {\n    U: \"blue\",\n    B: \"red\",\n    R: \"white\"\n  }\n}, {\n  id: \"UFL\",\n  position: [-1, 1, 1],\n  colors: {\n    U: \"blue\",\n    F: \"orange\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"UFR\",\n  position: [1, 1, 1],\n  colors: {\n    U: \"blue\",\n    F: \"orange\",\n    R: \"white\"\n  }\n}, {\n  id: \"DBL\",\n  position: [-1, -1, -1],\n  colors: {\n    D: \"green\",\n    B: \"red\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"DBR\",\n  position: [1, -1, -1],\n  colors: {\n    D: \"green\",\n    B: \"red\",\n    R: \"white\"\n  }\n}, {\n  id: \"DFL\",\n  position: [-1, -1, 1],\n  colors: {\n    D: \"green\",\n    F: \"orange\",\n    L: \"yellow\"\n  }\n}, {\n  id: \"DFR\",\n  position: [1, -1, 1],\n  colors: {\n    D: \"green\",\n    F: \"orange\",\n    R: \"white\"\n  }\n}];\n\n// Helper that decides exactly which layer to rotate, given the face clicked\n// and the (x,y,z) position of that cubie.\nfunction getLayerFromFaceAndPosition(face, x, y, z) {\n  // Convert to integers, since dataset attributes come as strings\n  x = parseInt(x, 10);\n  y = parseInt(y, 10);\n  z = parseInt(z, 10);\n  switch (face) {\n    case \"U\":\n      // Only rotate top layer if y=1\n      return y === 1 ? \"U\" : null;\n    case \"D\":\n      // Only rotate bottom layer if y=-1\n      return y === -1 ? \"D\" : null;\n    case \"F\":\n      // Only rotate front layer if z=1\n      return z === 1 ? \"F\" : null;\n    case \"B\":\n      // Only rotate back layer if z=-1\n      return z === -1 ? \"B\" : null;\n    case \"R\":\n      // Only rotate right layer if x=1\n      return x === 1 ? \"R\" : null;\n    case \"L\":\n      // Only rotate left layer if x=-1\n      return x === -1 ? \"L\" : null;\n    default:\n      return null;\n  }\n}\nconst Cube = () => {\n  _s();\n  const [cubeState, setCubeState] = useState(initialCubeState);\n  const [shouldSolve, setShouldSolve] = useState(false);\n  const [rotation, setRotation] = useState({\n    x: -30,\n    y: 45\n  }); // Whole-cube rotation\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({\n    x: 0,\n    y: 0\n  });\n  const [selectedLayer, setSelectedLayer] = useState(null);\n  const [solutionSteps, setSolutionSteps] = useState([]);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n\n  // --- MOUSE EVENTS ---\n  const handleMouseDown = event => {\n    // 1) Check if you clicked on a specific face via data-face\n    const faceElement = event.target.closest(\".cubie-face\");\n    if (faceElement) {\n      const face = faceElement.dataset.face; // e.g., \"U\", \"R\", ...\n      if (face) {\n        // Grab the parent .cubie to read its data-x, data-y, data-z\n        const cubieEl = faceElement.closest(\".cubie\");\n        if (cubieEl) {\n          const {\n            x,\n            y,\n            z\n          } = cubieEl.dataset;\n          // Figure out the *actual* layer to rotate, if any\n          const layer = getLayerFromFaceAndPosition(face, x, y, z);\n          if (layer) {\n            setSelectedLayer(layer);\n            setDragStart({\n              x: event.clientX,\n              y: event.clientY\n            });\n            return; // Skip rotating the whole cube\n          }\n        }\n      }\n    }\n\n    // 2) Otherwise, rotate the entire cube\n    setIsDragging(true);\n    setDragStart({\n      x: event.clientX,\n      y: event.clientY\n    });\n  };\n  const handleMouseMove = event => {\n    // A) If dragging the whole cube\n    const MAX_ROTATION_X = 90; // Maximum x rotation\n    const MIN_ROTATION_X = -90; // Minimum x rotation\n\n    if (isDragging) {\n      const deltaX = event.clientX - dragStart.x;\n      const deltaY = event.clientY - dragStart.y;\n\n      // Update x with the deltaY, but clamp it between MIN_ROTATION_X and MAX_ROTATION_X\n      setRotation(prev => {\n        const newX = prev.x - deltaY * 0.3;\n        const newY = prev.y + deltaX * 0.3;\n        return {\n          x: Math.max(MIN_ROTATION_X, Math.min(newX, MAX_ROTATION_X)),\n          // Clamp x\n          y: newY\n        };\n      });\n      setDragStart({\n        x: event.clientX,\n        y: event.clientY\n      });\n    }\n\n    // B) If dragging a face to rotate that layer\n    if (selectedLayer) {\n      const deltaX = event.clientX - dragStart.x;\n      if (Math.abs(deltaX) > 30) {\n        const direction = deltaX > 0 ? 90 : -90;\n        rotateLayerCubies(selectedLayer, direction);\n        setSelectedLayer(null); // Prevent repeated rotations on same drag\n      }\n    }\n  };\n  const handleMouseUp = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n  const handleMouseLeave = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n  const rotateLayerCubies = (layer, direction) => {\n    setCubeState(prevState => {\n      const newState = [...prevState];\n      let axisIndex, axisValue;\n      switch (layer) {\n        case \"U\":\n          axisIndex = 1; // y\n          axisValue = 1;\n          break;\n        case \"D\":\n          axisIndex = 1;\n          axisValue = -1;\n          break;\n        case \"F\":\n          axisIndex = 2; // z\n          axisValue = 1;\n          break;\n        case \"B\":\n          axisIndex = 2;\n          axisValue = -1;\n          break;\n        case \"R\":\n          axisIndex = 0; // x\n          axisValue = 1;\n          break;\n        case \"L\":\n          axisIndex = 0;\n          axisValue = -1;\n          break;\n        default:\n          return newState;\n      }\n      const affectedCubies = newState.filter(c => c.position[axisIndex] === axisValue);\n\n      // Helper to update a sticker only if it exists.\n      const updateColor = (colors, target, value) => {\n        return colors.hasOwnProperty(target) ? value : undefined;\n      };\n      const rotateCubie = cubie => {\n        const {\n          position,\n          colors\n        } = cubie;\n        const [x, y, z] = position;\n        let newPosition = [...position];\n        let newColors = {\n          ...colors\n        };\n\n        // Helper function: assign oldFace to newFace if oldFace existed, then delete oldFace\n        const reassignFace = (oldFace, newFace) => {\n          if (colors[oldFace]) {\n            newColors[newFace] = colors[oldFace];\n            //delete newColors[oldFace];\n          }\n        };\n        switch (layer) {\n          case \"U\":\n            if (direction > 0) {\n              // +90 around U\n              newPosition = [z, y, -x];\n              // Keep U face\n              if (colors.U) newColors.U = colors.U;\n\n              //F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"R\", \"B\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"L\", \"F\");\n            } else {\n              // -90 around U\n              newPosition = [-z, y, x];\n              if (colors.U) newColors.U = colors.U;\n\n              // F->L, L->B, B->R, R->F (the reverse mapping)\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"L\", \"B\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"R\", \"F\");\n            }\n            break;\n          case \"D\":\n            if (direction > 0) {\n              newPosition = [z, y, -x];\n              if (colors.D) newColors.D = colors.D;\n\n              // F->L, L->B, B->R, R->F (for example)\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"L\", \"F\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"R\", \"B\");\n            } else {\n              newPosition = [-z, y, x];\n              if (colors.D) newColors.D = colors.D;\n\n              // F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"R\", \"F\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"L\", \"B\");\n            }\n            break;\n          case \"F\":\n            if (direction > 0) {\n              newPosition = [y, -x, z];\n              if (colors.F) newColors.F = colors.F;\n\n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            } else {\n              newPosition = [-y, x, z];\n              if (colors.F) newColors.F = colors.F;\n\n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            }\n            break;\n          case \"B\":\n            if (direction > 0) {\n              newPosition = [-y, x, z];\n              if (colors.B) newColors.B = colors.B;\n\n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            } else {\n              newPosition = [y, -x, z];\n              if (colors.B) newColors.B = colors.B;\n\n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            }\n            break;\n          case \"R\":\n            if (direction > 0) {\n              newPosition = [x, z, -y];\n              if (colors.R) newColors.R = colors.R;\n\n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            } else {\n              newPosition = [x, -z, y];\n              if (colors.R) newColors.R = colors.R;\n\n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            }\n            break;\n          case \"L\":\n            if (direction > 0) {\n              newPosition = [x, -z, y];\n              if (colors.L) newColors.L = colors.L;\n\n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            } else {\n              newPosition = [x, z, -y];\n              if (colors.L) newColors.L = colors.L;\n\n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            }\n            break;\n        }\n        return {\n          ...cubie,\n          position: newPosition,\n          colors: newColors\n        };\n      };\n      const updated = {};\n      affectedCubies.forEach(cubie => {\n        updated[cubie.id] = rotateCubie(cubie);\n      });\n      return newState.map(c => updated[c.id] || c);\n    });\n  };\n  const scrambleCube = async () => {\n    // Decide how many random moves you want:\n    const SCRAMBLE_LENGTH = 15; // or 20, etc.\n\n    const faces = [\"U\", \"D\", \"L\", \"R\", \"F\", \"B\"];\n    const directions = [90, -90]; // clockwise or counterclockwise\n\n    const delay = ms => new Promise(resolve => setTimeout(resolve, ms)); // Delay function\n\n    for (let i = 0; i < SCRAMBLE_LENGTH; i++) {\n      const randomFace = faces[Math.floor(Math.random() * faces.length)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n\n      // rotateLayerCubies is your existing method to do 90° turns\n      rotateLayerCubies(randomFace, randomDir);\n\n      // Wait for a timeout before the next move (e.g., 300ms between moves)\n      await delay(300);\n    }\n  };\n  const flattenCubeStateByPosition = cubeState => {\n    // Convert color strings to single-letter codes\n    const getColorLetter = color => {\n      const colorMap = {\n        white: \"W\",\n        yellow: \"Y\",\n        blue: \"B\",\n        green: \"G\",\n        red: \"R\",\n        orange: \"O\"\n      };\n      return colorMap[color] || \"?\";\n    };\n\n    // ========== U FACE ========== \n    // y === 1, have a U sticker\n    const getUIndex = cubie => {\n      const [x, _, z] = cubie.position;\n      // Example: top-left => 0, top-right => 1, bottom-left => 2, bottom-right => 3\n      // Fill in the coordinates that physically match each slot.\n      // (Just like your existing getUIndex)\n      if (x === 1 && z === -1) return 2;\n      if (x === -1 && z === -1) return 3;\n      if (x === 1 && z === 1) return 0;\n      if (x === -1 && z === 1) return 1;\n      return 99;\n    };\n\n    // ========== D FACE ========== \n    // y === -1, have a D sticker\n    const getDIndex = cubie => {\n      const [x, _, z] = cubie.position;\n      // TODO: Decide how you'd like to label D's top-left => 0, top-right => 1, etc.\n      // For instance:\n      // if (x=-1,z=-1) => 0, (x=1,z=-1) => 1, (x=-1,z=1) => 2, (x=1,z=1) => 3\n      // or any arrangement that yields the correct “visual” order for D.\n      if (x === -1 && z === -1) return 2;\n      if (x === 1 && z === -1) return 3;\n      if (x === -1 && z === 1) return 0;\n      if (x === 1 && z === 1) return 1;\n      return 99;\n    };\n\n    // ========== F FACE ==========\n    const getFIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // y is your vertical axis, x is left-right, z=1 for front\n      // Decide which coordinate combos map to top-left => 0, top-right => 1, etc.\n      // Example:\n      // if (y=1, x=-1) => 0, (y=1, x=1) => 1, (y=-1, x=-1) => 2, (y=-1, x=1) => 3\n      // So you end up with top row = y=1, bottom row = y=-1, left col = x=-1, right col = x=1\n      if (y === 1 && x === -1) return 0;\n      if (y === 1 && x === 1) return 1;\n      if (y === -1 && x === -1) return 2;\n      if (y === -1 && x === 1) return 3;\n      return 99;\n    };\n\n    // ========== B FACE ==========\n    const getBIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // Similar logic for the back face (z=-1).\n      // If you want top-left => y=1,x=1 => 0, etc., fill it in:\n      if (y === 1 && x === 1) return 0;\n      if (y === 1 && x === -1) return 1;\n      if (y === -1 && x === 1) return 2;\n      if (y === -1 && x === -1) return 3;\n      return 99;\n    };\n\n    // ========== L FACE ==========\n    const getLIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // x = -1 for left\n      // Decide top-left => (?), top-right => (?), bottom-left => (?), etc.\n      // Possibly y=1 => top, z=-1 => left, etc.\n      if (y === 1 && z === 1) return 1;\n      if (y === 1 && z === -1) return 0;\n      if (y === -1 && z === 1) return 3;\n      if (y === -1 && z === -1) return 2;\n      return 99;\n    };\n\n    // ========== R FACE ==========\n    const getRIndex = cubie => {\n      const [x, y, z] = cubie.position;\n      // x=+1 for right\n      // Fill in your top-left -> index0, top-right -> index1, etc.\n      if (y === 1 && z === -1) return 1;\n      if (y === 1 && z === 1) return 0;\n      if (y === -1 && z === -1) return 3;\n      if (y === -1 && z === 1) return 2;\n      return 99;\n    };\n\n    // The main function to get stickers for each face:\n    const getFaceStickers = face => {\n      let filtered = [];\n      switch (face) {\n        case \"U\":\n          {\n            filtered = cubeState.filter(c => c.position[1] === 1 && c.colors.U);\n            filtered.sort((a, b) => getUIndex(a) - getUIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.U)).join(\"\");\n          }\n        case \"D\":\n          {\n            filtered = cubeState.filter(c => c.position[1] === -1 && c.colors.D);\n            filtered.sort((a, b) => getDIndex(a) - getDIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.D)).join(\"\");\n          }\n        case \"F\":\n          {\n            filtered = cubeState.filter(c => c.position[2] === 1 && c.colors.F);\n            filtered.sort((a, b) => getFIndex(a) - getFIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.F)).join(\"\");\n          }\n        case \"B\":\n          {\n            filtered = cubeState.filter(c => c.position[2] === -1 && c.colors.B);\n            filtered.sort((a, b) => getBIndex(a) - getBIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.B)).join(\"\");\n          }\n        case \"L\":\n          {\n            filtered = cubeState.filter(c => c.position[0] === -1 && c.colors.L);\n            filtered.sort((a, b) => getLIndex(a) - getLIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.L)).join(\"\");\n          }\n        case \"R\":\n          {\n            filtered = cubeState.filter(c => c.position[0] === 1 && c.colors.R);\n            filtered.sort((a, b) => getRIndex(a) - getRIndex(b));\n            return filtered.map(c => getColorLetter(c.colors.R)).join(\"\");\n          }\n        default:\n          return \"\";\n      }\n    };\n\n    // Flatten in the face order your solver expects\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    return faceOrder.map(face => getFaceStickers(face)).join(\"\");\n  };\n\n  // const checkSymmetryAndSolve = async () => {\n  //   // 1) Flatten the user’s current cube state\n  //   console.log(\"Cube state original format - Before update:\" , cubeState);\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   console.log(\"Flattened Cube String:\", cubeString);\n\n  //   try {\n  //     // 2) Call your /find_symmetry endpoint first\n  //     const res = await fetch(`${API_BASE_URL}/find_symmetry`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await res.json();\n\n  //     if (!data.found) {\n  //       console.log(\"No matching or symmetrical version found. Cannot solve.\");\n  //       return; // or show a UI error\n  //     }\n\n  //     // If found == true\n  //     if (data.state !== cubeString) {\n  //       // Means we have a symmetrical match that differs from the user's state\n  //       console.log(\"Server suggests symmetrical reorientation:\", data.state);\n  //       // 3) Reorient the cube to that symmetrical version\n  //       reorientCubeFromString(data.state);\n  //     }\n\n  //     else {\n  //       // If no reorientation is needed, we can still trigger the solver:\n  //       setShouldSolve(true);\n  //     }\n\n  //   } catch (err) {\n  //     console.error(\"Error checking symmetry:\", err);\n  //   }\n  // }\n\n  //   // useEffect to call solver after state is updated\n  // useEffect(() => {\n  //   if (shouldSolve) {\n  //     callSolveEndpoint(); // uses the *latest* cubeState\n  //     setShouldSolve(false);\n  //   }\n  // }, [cubeState, shouldSolve]);\n\n  // Example: callSolveEndpoint references your existing handleSolve logic\n  // const callSolveEndpoint = async () => {\n  //   console.log(\"Cube state original format - after update:\" , cubeState);\n\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   //const finalString = flattenCubeStateByPosition(cubeState);\n  //   // the existing logic from handleSolve\n  //   console.log(\"Cube state string - after upadate: \", cubeString);\n\n  //   try {\n  //     const response = await fetch(`${API_BASE_URL}/solve`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await response.json();\n  //     if (!data) {\n  //       console.log(\"no matching solution found\");\n  //       return;\n  //     }\n  //     guideUserThroughSolution(data.solution);\n  //   } catch (error) {\n  //     console.error(\"Error solving:\", error);\n  //   }\n  // };\n\n  function createBlankCubeState() {\n    return [{\n      id: \"UBL\",\n      position: [-1, 1, -1],\n      colors: {}\n    }, {\n      id: \"UBR\",\n      position: [1, 1, -1],\n      colors: {}\n    }, {\n      id: \"UFL\",\n      position: [-1, 1, 1],\n      colors: {}\n    }, {\n      id: \"UFR\",\n      position: [1, 1, 1],\n      colors: {}\n    }, {\n      id: \"DBL\",\n      position: [-1, -1, -1],\n      colors: {}\n    }, {\n      id: \"DBR\",\n      position: [1, -1, -1],\n      colors: {}\n    }, {\n      id: \"DFL\",\n      position: [-1, -1, 1],\n      colors: {}\n    }, {\n      id: \"DFR\",\n      position: [1, -1, 1],\n      colors: {}\n    }];\n  }\n  function reorientCubeFromString(cubeString) {\n    // We'll parse 24 characters in blocks of 4 for U,D,F,B,R,L\n    // For each block, we figure out which cubies get which face color\n\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    // A helper to convert a single letter like 'B' or 'O' back to e.g. \"blue\" or \"orange\"\n    const colorMapReverse = {\n      \"W\": \"white\",\n      \"Y\": \"yellow\",\n      \"B\": \"blue\",\n      \"G\": \"green\",\n      \"R\": \"red\",\n      \"O\": \"orange\"\n    };\n\n    // 1) Create a blank 8-cubie array\n    let newState = createBlankCubeState();\n\n    // 2) Define the “index → coordinate” for each face\n    const getUCoordinateByIndex = i => {\n      // Inverse of your getUIndex. \n      switch (i) {\n        case 2:\n          return [1, 1, -1];\n        // x=1,z=-1\n        case 3:\n          return [-1, 1, -1];\n        // x=-1,z=-1\n        case 0:\n          return [1, 1, 1];\n        // x=1,z=1\n        case 1:\n          return [-1, 1, 1];\n        // x=-1,z=1\n        default:\n          return \" \";\n      }\n    };\n    const getDCoordinateByIndex = i => {\n      switch (i) {\n        case 2:\n          return [-1, -1, -1];\n        case 3:\n          return [1, -1, -1];\n        case 0:\n          return [-1, -1, 1];\n        case 1:\n          return [1, -1, 1];\n        default:\n          return \" \";\n      }\n    };\n    const getFCoordinateByIndex = i => {\n      switch (i) {\n        case 0:\n          return [-1, 1, 1];\n        case 1:\n          return [1, 1, 1];\n        case 2:\n          return [-1, -1, 1];\n        case 3:\n          return [1, -1, 1];\n        default:\n          return \" \";\n      }\n    };\n    const getBCoordinateByIndex = i => {\n      switch (i) {\n        case 0:\n          return [1, 1, -1];\n        case 1:\n          return [-1, 1, -1];\n        case 2:\n          return [1, -1, -1];\n        case 3:\n          return [-1, -1, -1];\n        default:\n          return \" \";\n      }\n    };\n    const getLCoordinateByIndex = i => {\n      switch (i) {\n        case 1:\n          return [-1, 1, 1];\n        case 0:\n          return [-1, 1, -1];\n        case 3:\n          return [-1, -1, 1];\n        case 2:\n          return [-1, -1, -1];\n        default:\n          return \" \";\n      }\n    };\n    const getRCoordinateByIndex = i => {\n      switch (i) {\n        case 1:\n          return [1, 1, -1];\n        case 0:\n          return [1, 1, 1];\n        case 3:\n          return [1, -1, -1];\n        case 2:\n          return [1, -1, 1];\n        default:\n          return \" \";\n      }\n    };\n    // Similarly define getFCoordinateByIndex, getBCoordinateByIndex, etc...\n    // matching how you set up getFIndex, getBIndex, etc.\n\n    // 3) A helper that finds the cubie in newState that matches a coordinate\n    function findCubieByPosition(x, y, z) {\n      return newState.find(c => c.position[0] === x && c.position[1] === y && c.position[2] === z);\n    }\n\n    // 4) Parse the cubeString in 6 chunks of 4\n    let offset = 0;\n    for (let face of faceOrder) {\n      const faceChars = cubeString.slice(offset, offset + 4); // next 4 letters\n      offset += 4;\n      for (let i = 0; i < 4; i++) {\n        const letter = faceChars[i]; // e.g. 'B', 'O', 'W'\n        const colorString = colorMapReverse[letter] || \"unknown\";\n        let xyz;\n        if (face === \"U\") {\n          xyz = getUCoordinateByIndex(i);\n        } else if (face === \"D\") {\n          xyz = getDCoordinateByIndex(i);\n        } else if (face === \"F\") {\n          xyz = getFCoordinateByIndex(i);\n        } else if (face === \"B\") {\n          xyz = getBCoordinateByIndex(i);\n        } else if (face === \"R\") {\n          xyz = getRCoordinateByIndex(i);\n        } else if (face === \"L\") {\n          xyz = getLCoordinateByIndex(i);\n        }\n        const [x, y, z] = xyz;\n        // find the matching cubie\n        const cubie = findCubieByPosition(x, y, z);\n        if (cubie) {\n          cubie.colors[face] = colorString;\n        }\n      }\n    }\n    // fill in newState\n    setCubeState(newState);\n\n    // Also set a flag\n    //setShouldSolve(true);\n  }\n\n  // 1) \"Find Solution\" button\n  const handleFindSolution = async () => {\n    const cubeString = flattenCubeStateByPosition(cubeState);\n    try {\n      // Check for symmetry\n      const symmetryRes = await fetch(`${API_BASE_URL}/find_symmetry`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          cube_data: cubeString\n        })\n      });\n      const symmetryData = await symmetryRes.json();\n      if (!symmetryData.found) {\n        console.log(\"No symmetrical version found. Can't solve.\");\n        setSolutionSteps(null);\n        return;\n      }\n\n      // If we got a symmetrical match, reorient the cube\n      if (symmetryData.state !== cubeString) {\n        reorientCubeFromString(symmetryData.state);\n        console.log(\"notice: cube switch to identical symmetic state - adapt your cube with this symmetrica state\");\n      }\n\n      // Now request the solution steps from /solve\n      const solveRes = await fetch(`${API_BASE_URL}/solve`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          cube_data: symmetryData.state\n        })\n      });\n      const solveData = await solveRes.json();\n      if (!(solveData !== null && solveData !== void 0 && solveData.solution)) {\n        console.log(\"No solution returned.\");\n        setSolutionSteps(null);\n        return;\n      }\n\n      // Store the solution steps in state\n      setSolutionSteps(solveData.solution);\n      console.log(\"Solution steps are ready. Click 'Guide Me' to start solving.\");\n    } catch (err) {\n      console.error(\"Error finding or solving:\", err);\n    }\n  };\n\n  // 2) \"Guide Me\" button\n  const handleGuideMe = () => {\n    if (!solutionSteps || solutionSteps.length === 0) {\n      console.log(\"No solution steps. Click 'Find Solution' first.\");\n      return;\n    }\n    // Start from the first move\n    setCurrentStepIndex(0);\n    showManualStep(0);\n  };\n\n  // const guideUserThroughSolution = async (solutionMoves) => {\n  //   for (const layer of solutionMoves) {\n\n  //     if (layer === \"Congratulations!\") {\n  //       console.log(\"Done!\");\n  //       return;\n  //     }\n\n  //     let direction = 90;\n  //     if (layer === \"B\" || layer === \"L\") {\n  //       direction = -90;\n  //     }\n  //     // Show guidance with an arrow\n  //     showArrowOnFace(layer, direction);\n\n  //     // Wait before animating the move\n  //     await delay(1000);  // 1-second pause before executing the move\n\n  //     // Perform the rotation (animate and update state)\n  //     rotateLayerCubies(layer, direction);\n\n  //     // Remove the arrow after the move\n  //     removeArrowFromFace(layer);\n\n  //     // Wait before moving to the next step\n  //     await delay(1000);\n  //   }\n\n  //   // Final success message\n  //   showSuccessMessage();\n  // };\n\n  const showManualStep = index => {\n    // If we’re beyond the last move, show success\n    if (index >= solutionSteps.length) {\n      showSuccessMessage();\n      return;\n    }\n    const layer = solutionSteps[index];\n    // If it's some special marker like \"Congratulations!\"\n    if (layer === \"Congratulations!\") {\n      showSuccessMessage();\n      return;\n    }\n\n    // Determine arrow direction\n    let direction = 90;\n    if (layer === \"B\" || layer === \"L\") {\n      direction = -90;\n    }\n\n    // Display the arrow on the correct face\n    showArrowsOnLayer(layer, direction);\n\n    // Now we wait for the user to rotate manually...\n    // The user will click \"Next\" or some UI button once they’ve done the move\n  };\n  const handleUserRotationDone = () => {\n    // Remove the arrow from the current face\n    const layer = solutionSteps[currentStepIndex];\n    removeArrowsFromLayer(layer);\n\n    // Move on to the next step\n    const nextIndex = currentStepIndex + 1;\n    setCurrentStepIndex(nextIndex);\n    showManualStep(nextIndex);\n  };\n  const showArrowsOnLayer = (layer, direction) => {\n    // Grab all .cubie-face elements whose data-face matches\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n    faceElements.forEach(face => {\n      // Create the arrow element\n      const arrow = document.createElement(\"div\");\n      arrow.classList.add(\"rotation-arrow\");\n      //arrow.classList.add(`rotation-arrow-${layer.toLowerCase()}`); // <--- add this line\n\n      // Choose a symbol for clockwise vs. counterclockwise\n      if (layer == \"U\") {\n        arrow.innerHTML = direction < 0 ? \"↻\" : \"↺\";\n      } else {\n        arrow.innerHTML = direction > 0 ? \"↻\" : \"↺\";\n      }\n\n      // Append the arrow to the face\n      face.appendChild(arrow);\n    });\n  };\n\n  // Remove arrows from every face in that layer\n  const removeArrowsFromLayer = layer => {\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n    faceElements.forEach(face => {\n      const arrow = face.querySelector(\".rotation-arrow\");\n      if (arrow) arrow.remove();\n    });\n  };\n  const showSuccessMessage = () => {\n    const messageBox = document.createElement(\"div\");\n    messageBox.classList.add(\"success-message\");\n    messageBox.innerText = \"🎉 Cube Solved!\";\n    document.body.appendChild(messageBox);\n    setTimeout(() => {\n      messageBox.remove(); // Remove after 3 seconds\n    }, 3000);\n  };\n  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  // --- RENDERING ---\n  const renderCubies = () => cubeState.map(cubie => {\n    const {\n      id,\n      position,\n      colors\n    } = cubie;\n    const [cx, cy, cz] = position;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"cubie\",\n      \"data-x\": cx // So we can read them on click\n      ,\n      \"data-y\": cy,\n      \"data-z\": cz,\n      style: {\n        position: \"absolute\",\n        width: \"88px\",\n        height: \"88px\",\n        transform: `translate3d(${cx * 45}px, ${-cy * 45}px, ${cz * 45}px)`,\n        transformStyle: \"preserve-3d\"\n      },\n      children: Object.entries(colors).map(([face, color]) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"cubie-face\",\n        \"data-face\": face // e.g., \"U\", \"D\", \"F\", etc.\n        ,\n        style: {\n          position: \"absolute\",\n          width: \"80px\",\n          height: \"80px\",\n          border: \"8px solid black\",\n          backgroundColor: color,\n          transform: getFaceTransform(face),\n          cursor: \"pointer\"\n        }\n      }, face, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1016,\n        columnNumber: 13\n      }, this))\n    }, id, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1001,\n      columnNumber: 9\n    }, this);\n  });\n\n  // Places each face in the correct orientation\n  const getFaceTransform = face => {\n    switch (face) {\n      case \"U\":\n        return \"rotateX(90deg) translateZ(45px)\";\n      case \"D\":\n        return \"rotateX(-90deg) translateZ(45px)\";\n      case \"F\":\n        return \"translateZ(45px)\";\n      case \"B\":\n        return \"rotateY(180deg) translateZ(45px)\";\n      case \"L\":\n        return \"rotateY(-90deg) translateZ(45px)\";\n      case \"R\":\n        return \"rotateY(90deg) translateZ(45px)\";\n      default:\n        return \"\";\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: scrambleCube,\n      children: \"Scramble\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1059,\n      columnNumber: 7\n    }, this), \" \", /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleFindSolution,\n      children: \"Find Solution\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1060,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleGuideMe,\n      children: \"Guide Me\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1061,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleUserRotationDone,\n      children: \"Next Move\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1062,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"cube-container\",\n      onMouseDown: handleMouseDown,\n      onMouseMove: handleMouseMove,\n      onMouseUp: handleMouseUp,\n      onMouseLeave: handleMouseLeave,\n      style: {\n        width: \"700px\",\n        height: \"700px\",\n        position: \"relative\"\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"cube\",\n        style: {\n          transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`,\n          transformStyle: \"preserve-3d\",\n          position: \"absolute\",\n          width: \"100px\",\n          height: \"100px\"\n        },\n        children: renderCubies()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1071,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1063,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1058,\n    columnNumber: 5\n  }, this);\n};\n_s(Cube, \"nLW1JS+EUA9+YGNrEyakjnyPaW8=\");\n_c = Cube;\nexport default Cube; // Export the Cube component\nvar _c;\n$RefreshReg$(_c, \"Cube\");","map":{"version":3,"names":["React","useState","useEffect","API_BASE_URL","jsxDEV","_jsxDEV","initialCubeState","id","position","colors","U","B","L","R","F","D","getLayerFromFaceAndPosition","face","x","y","z","parseInt","Cube","_s","cubeState","setCubeState","shouldSolve","setShouldSolve","rotation","setRotation","isDragging","setIsDragging","dragStart","setDragStart","selectedLayer","setSelectedLayer","solutionSteps","setSolutionSteps","currentStepIndex","setCurrentStepIndex","handleMouseDown","event","faceElement","target","closest","dataset","cubieEl","layer","clientX","clientY","handleMouseMove","MAX_ROTATION_X","MIN_ROTATION_X","deltaX","deltaY","prev","newX","newY","Math","max","min","abs","direction","rotateLayerCubies","handleMouseUp","handleMouseLeave","prevState","newState","axisIndex","axisValue","affectedCubies","filter","c","updateColor","value","hasOwnProperty","undefined","rotateCubie","cubie","newPosition","newColors","reassignFace","oldFace","newFace","updated","forEach","map","scrambleCube","SCRAMBLE_LENGTH","faces","directions","delay","ms","Promise","resolve","setTimeout","i","randomFace","floor","random","length","randomDir","flattenCubeStateByPosition","getColorLetter","color","colorMap","white","yellow","blue","green","red","orange","getUIndex","_","getDIndex","getFIndex","getBIndex","getLIndex","getRIndex","getFaceStickers","filtered","sort","a","b","join","faceOrder","createBlankCubeState","reorientCubeFromString","cubeString","colorMapReverse","getUCoordinateByIndex","getDCoordinateByIndex","getFCoordinateByIndex","getBCoordinateByIndex","getLCoordinateByIndex","getRCoordinateByIndex","findCubieByPosition","find","offset","faceChars","slice","letter","colorString","xyz","handleFindSolution","symmetryRes","fetch","method","headers","body","JSON","stringify","cube_data","symmetryData","json","found","console","log","state","solveRes","solveData","solution","err","error","handleGuideMe","showManualStep","index","showSuccessMessage","showArrowsOnLayer","handleUserRotationDone","removeArrowsFromLayer","nextIndex","faceElements","document","querySelectorAll","arrow","createElement","classList","add","innerHTML","appendChild","querySelector","remove","messageBox","innerText","renderCubies","cx","cy","cz","className","style","width","height","transform","transformStyle","children","Object","entries","border","backgroundColor","getFaceTransform","cursor","fileName","_jsxFileName","lineNumber","columnNumber","onClick","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","_c","$RefreshReg$"],"sources":["/home/gal98/projects/pocket-cube-solver/frontend/src/components/Cube.js"],"sourcesContent":["/* eslint-disable default-case */\nimport React, { useState, useEffect } from \"react\";\nimport \"./Cube.css\";\nimport API_BASE_URL from \"../config\";\n\n// const defaultColors = {\n//   U: \"blue\",   // Up\n//   D: \"green\",  // Down\n//   F: \"orange\", // Front\n//   B: \"red\",    // Back\n//   L: \"white\",  // Left\n//   R: \"yellow\", // Right\n// };\n\n\nconst initialCubeState = [\n  {\n    id: \"UBL\",\n    position: [-1, 1, -1],\n    colors: { U: \"blue\", B: \"red\", L: \"yellow\" },\n  },\n  {\n    id: \"UBR\",\n    position: [1, 1, -1],\n    colors: { U: \"blue\", B: \"red\", R: \"white\" },\n  },\n  {\n    id: \"UFL\",\n    position: [-1, 1, 1],\n    colors: { U: \"blue\", F: \"orange\", L: \"yellow\" },\n  },\n  {\n    id: \"UFR\",\n    position: [1, 1, 1],\n    colors: { U: \"blue\", F: \"orange\", R: \"white\" },\n  },\n  {\n    id: \"DBL\",\n    position: [-1, -1, -1],\n    colors: { D: \"green\", B: \"red\", L: \"yellow\" },\n  },\n  {\n    id: \"DBR\",\n    position: [1, -1, -1],\n    colors: { D: \"green\", B: \"red\", R: \"white\" },\n  },\n  {\n    id: \"DFL\",\n    position: [-1, -1, 1],\n    colors: { D: \"green\", F: \"orange\", L: \"yellow\" },\n  },\n  {\n    id: \"DFR\",\n    position: [1, -1, 1],\n    colors: { D: \"green\", F: \"orange\", R: \"white\" },\n  },\n];\n\n\n// Helper that decides exactly which layer to rotate, given the face clicked\n// and the (x,y,z) position of that cubie.\nfunction getLayerFromFaceAndPosition(face, x, y, z) {\n  // Convert to integers, since dataset attributes come as strings\n  x = parseInt(x, 10);\n  y = parseInt(y, 10);\n  z = parseInt(z, 10);\n\n  switch (face) {\n    case \"U\":\n      // Only rotate top layer if y=1\n      return y === 1 ? \"U\" : null;\n\n    case \"D\":\n      // Only rotate bottom layer if y=-1\n      return y === -1 ? \"D\" : null;\n\n    case \"F\":\n      // Only rotate front layer if z=1\n      return z === 1 ? \"F\" : null;\n\n    case \"B\":\n      // Only rotate back layer if z=-1\n      return z === -1 ? \"B\" : null;\n\n    case \"R\":\n      // Only rotate right layer if x=1\n      return x === 1 ? \"R\" : null;\n\n    case \"L\":\n      // Only rotate left layer if x=-1\n      return x === -1 ? \"L\" : null;\n\n    default:\n      return null;\n  }\n}\n\nconst Cube = () => {\n  const [cubeState, setCubeState] = useState(initialCubeState);\n  const [shouldSolve, setShouldSolve] = useState(false);\n  const [rotation, setRotation] = useState({ x: -30, y: 45 }); // Whole-cube rotation\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const [selectedLayer, setSelectedLayer] = useState(null);\n  const [solutionSteps, setSolutionSteps] = useState([]);\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  \n\n  // --- MOUSE EVENTS ---\n  const handleMouseDown = (event) => {\n    // 1) Check if you clicked on a specific face via data-face\n    const faceElement = event.target.closest(\".cubie-face\");\n    if (faceElement) {\n      const face = faceElement.dataset.face; // e.g., \"U\", \"R\", ...\n      if (face) {\n        // Grab the parent .cubie to read its data-x, data-y, data-z\n        const cubieEl = faceElement.closest(\".cubie\");\n        if (cubieEl) {\n          const { x, y, z } = cubieEl.dataset;\n          // Figure out the *actual* layer to rotate, if any\n          const layer = getLayerFromFaceAndPosition(face, x, y, z);\n\n          if (layer) {\n            setSelectedLayer(layer);\n            setDragStart({ x: event.clientX, y: event.clientY });\n            return; // Skip rotating the whole cube\n          }\n        }\n      }\n    }\n\n    // 2) Otherwise, rotate the entire cube\n    setIsDragging(true);\n    setDragStart({ x: event.clientX, y: event.clientY });\n  };\n\n  const handleMouseMove = (event) => {\n    // A) If dragging the whole cube\n    const MAX_ROTATION_X = 90;  // Maximum x rotation\n    const MIN_ROTATION_X = -90; // Minimum x rotation\n    \n    if (isDragging) {\n      const deltaX = event.clientX - dragStart.x;\n      const deltaY = event.clientY - dragStart.y;\n    \n      // Update x with the deltaY, but clamp it between MIN_ROTATION_X and MAX_ROTATION_X\n      setRotation((prev) => {\n        const newX = prev.x - deltaY * 0.3;\n        const newY = prev.y + deltaX * 0.3;\n    \n        return {\n          x: Math.max(MIN_ROTATION_X, Math.min(newX, MAX_ROTATION_X)), // Clamp x\n          y: newY,\n        };\n      });\n    \n      setDragStart({ x: event.clientX, y: event.clientY });\n    }\n    \n\n    // B) If dragging a face to rotate that layer\n    if (selectedLayer) {\n      const deltaX = event.clientX - dragStart.x;\n      if (Math.abs(deltaX) > 30) {\n        const direction = deltaX > 0 ? 90 : -90;\n        rotateLayerCubies(selectedLayer, direction);\n        setSelectedLayer(null); // Prevent repeated rotations on same drag\n      }\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n\n  const handleMouseLeave = () => {\n    setIsDragging(false);\n    setSelectedLayer(null);\n  };\n\n  const rotateLayerCubies = (layer, direction) => {\n    setCubeState((prevState) => {\n      const newState = [...prevState];\n      let axisIndex, axisValue;\n      switch (layer) {\n        case \"U\":\n          axisIndex = 1; // y\n          axisValue = 1;\n          break;\n        case \"D\":\n          axisIndex = 1;\n          axisValue = -1;\n          break;\n        case \"F\":\n          axisIndex = 2; // z\n          axisValue = 1;\n          break;\n        case \"B\":\n          axisIndex = 2;\n          axisValue = -1;\n          break;\n        case \"R\":\n          axisIndex = 0; // x\n          axisValue = 1;\n          break;\n        case \"L\":\n          axisIndex = 0;\n          axisValue = -1;\n          break;\n        default:\n          return newState;\n      }\n      const affectedCubies = newState.filter(\n        (c) => c.position[axisIndex] === axisValue\n      );\n  \n      // Helper to update a sticker only if it exists.\n      const updateColor = (colors, target, value) => {\n        return colors.hasOwnProperty(target) ? value : undefined;\n      };\n  \n      const rotateCubie = (cubie) => {\n        const { position, colors } = cubie;\n        const [x, y, z] = position;\n        let newPosition = [...position];\n        let newColors = { ...colors };\n      \n        // Helper function: assign oldFace to newFace if oldFace existed, then delete oldFace\n        const reassignFace = (oldFace, newFace) => {\n          if (colors[oldFace]) {\n            newColors[newFace] = colors[oldFace];\n            //delete newColors[oldFace];\n          }\n        };\n      \n        switch (layer) {\n          case \"U\":\n            if (direction > 0) {\n              // +90 around U\n              newPosition = [z, y, -x];\n              // Keep U face\n              if (colors.U) newColors.U = colors.U;\n      \n              //F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"R\", \"B\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"L\", \"F\");\n            } else {\n              // -90 around U\n              newPosition = [-z, y, x];\n              if (colors.U) newColors.U = colors.U;\n      \n              // F->L, L->B, B->R, R->F (the reverse mapping)\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"L\", \"B\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"R\", \"F\");\n            }\n            break;\n      \n          case \"D\":\n            if (direction > 0) {\n              newPosition = [z, y, -x];\n              if (colors.D) newColors.D = colors.D;\n      \n              // F->L, L->B, B->R, R->F (for example)\n              reassignFace(\"F\", \"R\");\n              reassignFace(\"L\", \"F\");\n              reassignFace(\"B\", \"L\");\n              reassignFace(\"R\", \"B\");\n\n\n\n            } else {\n              newPosition = [-z, y, x];\n              if (colors.D) newColors.D = colors.D;\n      \n              // F->R, R->B, B->L, L->F\n              reassignFace(\"F\", \"L\");\n              reassignFace(\"R\", \"F\");\n              reassignFace(\"B\", \"R\");\n              reassignFace(\"L\", \"B\");\n            }\n            break;\n      \n          case \"F\":\n            if (direction > 0) {\n              newPosition = [y, -x, z];\n              if (colors.F) newColors.F = colors.F;\n      \n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            } else {\n              newPosition = [-y, x, z];\n              if (colors.F) newColors.F = colors.F;\n      \n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            }\n            break;\n      \n          case \"B\":\n            if (direction > 0) {\n              newPosition = [-y, x, z];\n              if (colors.B) newColors.B = colors.B;\n      \n              // U->R, R->D, D->L, L->U\n              reassignFace(\"L\", \"D\");\n              reassignFace(\"U\", \"L\");\n              reassignFace(\"R\", \"U\");\n              reassignFace(\"D\", \"R\");\n            } else {\n              newPosition = [y, -x, z];\n              if (colors.B) newColors.B = colors.B;\n      \n              // U->L, L->D, D->R, R->U\n              reassignFace(\"R\", \"D\");\n              reassignFace(\"U\", \"R\");\n              reassignFace(\"L\", \"U\");\n              reassignFace(\"D\", \"L\");\n            }\n            break;\n      \n          case \"R\":\n            if (direction > 0) {\n              newPosition = [x, z, -y];\n              if (colors.R) newColors.R = colors.R;\n      \n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            } else {\n              newPosition = [x, -z, y];\n              if (colors.R) newColors.R = colors.R;\n      \n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            }\n            break;\n      \n          case \"L\":\n            if (direction > 0) {\n              newPosition = [x, -z, y];\n              if (colors.L) newColors.L = colors.L;\n      \n              // U->B, B->D, D->F, F->U\n              reassignFace(\"B\", \"U\");\n              reassignFace(\"U\", \"F\");\n              reassignFace(\"F\", \"D\");\n              reassignFace(\"D\", \"B\");\n            } else {\n              newPosition = [x, z, -y];\n              if (colors.L) newColors.L = colors.L;\n      \n              // U->F, F->D, D->B, B->U\n              reassignFace(\"F\", \"U\");\n              reassignFace(\"U\", \"B\");\n              reassignFace(\"B\", \"D\");\n              reassignFace(\"D\", \"F\");\n            }\n            break;\n        }\n      \n        return { ...cubie, position: newPosition, colors: newColors };\n      };\n      \n  \n      const updated = {};\n      affectedCubies.forEach((cubie) => {\n        updated[cubie.id] = rotateCubie(cubie);\n      });\n  \n      return newState.map((c) => updated[c.id] || c);\n    });\n  };\n  \n  const scrambleCube = async () => {\n    // Decide how many random moves you want:\n    const SCRAMBLE_LENGTH = 15; // or 20, etc.\n\n    const faces = [\"U\", \"D\", \"L\", \"R\", \"F\", \"B\"];\n    const directions = [90, -90]; // clockwise or counterclockwise\n\n    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms)); // Delay function\n\n    for (let i = 0; i < SCRAMBLE_LENGTH; i++) {\n      const randomFace = faces[Math.floor(Math.random() * faces.length)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      \n      // rotateLayerCubies is your existing method to do 90° turns\n      rotateLayerCubies(randomFace, randomDir);\n\n      // Wait for a timeout before the next move (e.g., 300ms between moves)\n      await delay(300); \n    }\n  };\n\n  const flattenCubeStateByPosition = (cubeState) => {\n    // Convert color strings to single-letter codes\n    const getColorLetter = (color) => {\n      const colorMap = {\n        white: \"W\",\n        yellow: \"Y\",\n        blue: \"B\",\n        green: \"G\",\n        red: \"R\",\n        orange: \"O\",\n      };\n      return colorMap[color] || \"?\";\n    };\n\n    // ========== U FACE ========== \n    // y === 1, have a U sticker\n    const getUIndex = (cubie) => {\n      const [x, _, z] = cubie.position;\n      // Example: top-left => 0, top-right => 1, bottom-left => 2, bottom-right => 3\n      // Fill in the coordinates that physically match each slot.\n      // (Just like your existing getUIndex)\n      if (x ===  1 && z === -1) return 2;  \n      if (x === -1 && z === -1) return 3;\n      if (x ===  1 && z ===  1) return 0;\n      if (x === -1 && z ===  1) return 1;\n      return 99; \n    };\n\n    // ========== D FACE ========== \n    // y === -1, have a D sticker\n    const getDIndex = (cubie) => {\n      const [x, _, z] = cubie.position;\n      // TODO: Decide how you'd like to label D's top-left => 0, top-right => 1, etc.\n      // For instance:\n      // if (x=-1,z=-1) => 0, (x=1,z=-1) => 1, (x=-1,z=1) => 2, (x=1,z=1) => 3\n      // or any arrangement that yields the correct “visual” order for D.\n      if (x === -1 && z === -1) return 2;\n      if (x ===  1 && z === -1) return 3;\n      if (x === -1 && z ===  1) return 0;\n      if (x ===  1 && z ===  1) return 1;\n      return 99;\n    };\n\n    // ========== F FACE ==========\n    const getFIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // y is your vertical axis, x is left-right, z=1 for front\n      // Decide which coordinate combos map to top-left => 0, top-right => 1, etc.\n      // Example:\n      // if (y=1, x=-1) => 0, (y=1, x=1) => 1, (y=-1, x=-1) => 2, (y=-1, x=1) => 3\n      // So you end up with top row = y=1, bottom row = y=-1, left col = x=-1, right col = x=1\n      if (y ===  1 && x === -1) return 0;\n      if (y ===  1 && x ===  1) return 1;\n      if (y === -1 && x === -1) return 2;\n      if (y === -1 && x ===  1) return 3;\n      return 99;\n    };\n\n    // ========== B FACE ==========\n    const getBIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // Similar logic for the back face (z=-1).\n      // If you want top-left => y=1,x=1 => 0, etc., fill it in:\n      if (y ===  1 && x ===  1) return 0;\n      if (y ===  1 && x === -1) return 1;\n      if (y === -1 && x ===  1) return 2;\n      if (y === -1 && x === -1) return 3;\n      return 99;\n    };\n\n    // ========== L FACE ==========\n    const getLIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // x = -1 for left\n      // Decide top-left => (?), top-right => (?), bottom-left => (?), etc.\n      // Possibly y=1 => top, z=-1 => left, etc.\n      if (y === 1 && z === 1) return 1;\n      if (y === 1 && z === -1) return 0;\n      if (y === -1 && z === 1) return 3;\n      if (y === -1 && z === -1) return 2;\n      return 99;\n    };\n\n    // ========== R FACE ==========\n    const getRIndex = (cubie) => {\n      const [x, y, z] = cubie.position;\n      // x=+1 for right\n      // Fill in your top-left -> index0, top-right -> index1, etc.\n      if (y ===  1 && z === -1) return 1;\n      if (y ===  1 && z ===  1)  return 0;\n      if (y === -1 && z === -1) return 3;\n      if (y === -1 && z ===  1) return 2;\n      return 99;\n    };\n\n    // The main function to get stickers for each face:\n    const getFaceStickers = (face) => {\n      let filtered = [];\n      switch (face) {\n        case \"U\": {\n          filtered = cubeState.filter(c => c.position[1] === 1 && c.colors.U);\n          filtered.sort((a, b) => getUIndex(a) - getUIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.U)).join(\"\");\n        }\n        case \"D\": {\n          filtered = cubeState.filter(c => c.position[1] === -1 && c.colors.D);\n          filtered.sort((a, b) => getDIndex(a) - getDIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.D)).join(\"\");\n        }\n        case \"F\": {\n          filtered = cubeState.filter(c => c.position[2] === 1 && c.colors.F);\n          filtered.sort((a, b) => getFIndex(a) - getFIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.F)).join(\"\");\n        }\n        case \"B\": {\n          filtered = cubeState.filter(c => c.position[2] === -1 && c.colors.B);\n          filtered.sort((a, b) => getBIndex(a) - getBIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.B)).join(\"\");\n        }\n        case \"L\": {\n          filtered = cubeState.filter(c => c.position[0] === -1 && c.colors.L);\n          filtered.sort((a, b) => getLIndex(a) - getLIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.L)).join(\"\");\n        }\n        case \"R\": {\n          filtered = cubeState.filter(c => c.position[0] === 1 && c.colors.R);\n          filtered.sort((a, b) => getRIndex(a) - getRIndex(b));\n          return filtered.map(c => getColorLetter(c.colors.R)).join(\"\");\n        }\n        default:\n          return \"\";\n      }\n    };\n\n    // Flatten in the face order your solver expects\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    return faceOrder.map(face => getFaceStickers(face)).join(\"\");\n  };\n\n\n\n\n  // const checkSymmetryAndSolve = async () => {\n  //   // 1) Flatten the user’s current cube state\n  //   console.log(\"Cube state original format - Before update:\" , cubeState);\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   console.log(\"Flattened Cube String:\", cubeString);\n\n  //   try {\n  //     // 2) Call your /find_symmetry endpoint first\n  //     const res = await fetch(`${API_BASE_URL}/find_symmetry`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await res.json();\n      \n  //     if (!data.found) {\n  //       console.log(\"No matching or symmetrical version found. Cannot solve.\");\n  //       return; // or show a UI error\n  //     }\n      \n  //     // If found == true\n  //     if (data.state !== cubeString) {\n  //       // Means we have a symmetrical match that differs from the user's state\n  //       console.log(\"Server suggests symmetrical reorientation:\", data.state);\n  //       // 3) Reorient the cube to that symmetrical version\n  //       reorientCubeFromString(data.state);\n  //     }\n\n  //     else {\n  //       // If no reorientation is needed, we can still trigger the solver:\n  //       setShouldSolve(true);\n  //     }\n\n      \n  //   } catch (err) {\n  //     console.error(\"Error checking symmetry:\", err);\n  //   }\n  // }\n\n  //   // useEffect to call solver after state is updated\n  // useEffect(() => {\n  //   if (shouldSolve) {\n  //     callSolveEndpoint(); // uses the *latest* cubeState\n  //     setShouldSolve(false);\n  //   }\n  // }, [cubeState, shouldSolve]);\n  \n  // Example: callSolveEndpoint references your existing handleSolve logic\n  // const callSolveEndpoint = async () => {\n  //   console.log(\"Cube state original format - after update:\" , cubeState);\n\n  //   const cubeString = flattenCubeStateByPosition(cubeState);\n  //   //const finalString = flattenCubeStateByPosition(cubeState);\n  //   // the existing logic from handleSolve\n  //   console.log(\"Cube state string - after upadate: \", cubeString);\n\n  //   try {\n  //     const response = await fetch(`${API_BASE_URL}/solve`, {\n  //       method: \"POST\",\n  //       headers: { \"Content-Type\": \"application/json\" },\n  //       body: JSON.stringify({ cube_data: cubeString }),\n  //     });\n  //     const data = await response.json();\n  //     if (!data) {\n  //       console.log(\"no matching solution found\");\n  //       return;\n  //     }\n  //     guideUserThroughSolution(data.solution);\n  //   } catch (error) {\n  //     console.error(\"Error solving:\", error);\n  //   }\n  // };\n  \n  \n  function createBlankCubeState() {\n    return [\n      {\n        id: \"UBL\",\n        position: [-1, 1, -1],\n        colors: {},\n      },\n      {\n        id: \"UBR\",\n        position: [1, 1, -1],\n        colors: {},\n      },\n      {\n        id: \"UFL\",\n        position: [-1, 1, 1],\n        colors: {},\n      },\n      {\n        id: \"UFR\",\n        position: [1, 1, 1],\n        colors: {},\n      },\n      {\n        id: \"DBL\",\n        position: [-1, -1, -1],\n        colors: {},\n      },\n      {\n        id: \"DBR\",\n        position: [1, -1, -1],\n        colors: {},\n      },\n      {\n        id: \"DFL\",\n        position: [-1, -1, 1],\n        colors: {},\n      },\n      {\n        id: \"DFR\",\n        position: [1, -1, 1],\n        colors: {},\n      },\n    ];\n  }\n  \n\n  function reorientCubeFromString(cubeString) {\n  // We'll parse 24 characters in blocks of 4 for U,D,F,B,R,L\n  // For each block, we figure out which cubies get which face color\n\n    const faceOrder = [\"U\", \"D\", \"F\", \"B\", \"R\", \"L\"];\n    // A helper to convert a single letter like 'B' or 'O' back to e.g. \"blue\" or \"orange\"\n    const colorMapReverse = {\n      \"W\": \"white\",\n      \"Y\": \"yellow\",\n      \"B\": \"blue\",\n      \"G\": \"green\",\n      \"R\": \"red\",\n      \"O\": \"orange\",\n    };\n\n    // 1) Create a blank 8-cubie array\n    let newState = createBlankCubeState();\n\n    // 2) Define the “index → coordinate” for each face\n    const getUCoordinateByIndex = (i) => {\n      // Inverse of your getUIndex. \n      switch(i) {\n        case 2: return [1, 1, -1];   // x=1,z=-1\n        case 3: return [-1,1, -1];  // x=-1,z=-1\n        case 0: return [1, 1, 1];    // x=1,z=1\n        case 1: return [-1,1, 1];    // x=-1,z=1\n        default:\n          return \" \"\n      }\n    };\n\n    const getDCoordinateByIndex = (i) => {\n      switch(i) {\n        case 2: return [-1,-1,-1];\n        case 3: return [1, -1, -1];\n        case 0: return [-1,-1, 1];\n        case 1: return [1, -1, 1];\n        default:\n          return \" \"\n      }\n    };\n\n    const getFCoordinateByIndex = (i) => {\n      switch(i) {\n        case 0: return [-1,1,1];\n        case 1: return [1, 1,1];\n        case 2: return [-1,-1,1];\n        case 3: return [1, -1,1];\n        default:\n          return \" \"\n      }\n    };\n\n    \n    const getBCoordinateByIndex = (i) => {\n      switch(i) {\n        case 0: return [1,1,-1];\n        case 1: return [-1, 1,-1];\n        case 2: return [1,-1,-1];\n        case 3: return [-1, -1,-1];\n        default:\n          return \" \"\n      }\n    };\n\n    const getLCoordinateByIndex = (i) => {\n      switch(i) {\n        case 1: return [-1,1,1];\n        case 0: return [-1, 1,-1];\n        case 3: return [-1,-1,1];\n        case 2: return [-1, -1,-1];\n        default:\n          return \" \"\n      }\n    };\n\n    \n    const getRCoordinateByIndex = (i) => {\n      switch(i) {\n        case 1: return [1,1,-1];\n        case 0: return [1, 1,1];\n        case 3: return [1,-1,-1];\n        case 2: return [1, -1,1];\n        default:\n          return \" \"\n      }\n    };\n    // Similarly define getFCoordinateByIndex, getBCoordinateByIndex, etc...\n    // matching how you set up getFIndex, getBIndex, etc.\n\n    // 3) A helper that finds the cubie in newState that matches a coordinate\n    function findCubieByPosition(x, y, z) {\n      return newState.find(c => \n        c.position[0] === x &&\n        c.position[1] === y &&\n        c.position[2] === z\n      );\n    }\n\n    // 4) Parse the cubeString in 6 chunks of 4\n    let offset = 0;\n    for (let face of faceOrder) {\n      const faceChars = cubeString.slice(offset, offset+4); // next 4 letters\n      offset += 4;\n\n      for (let i = 0; i < 4; i++) {\n        const letter = faceChars[i];  // e.g. 'B', 'O', 'W'\n        const colorString = colorMapReverse[letter] || \"unknown\";\n\n        let xyz;\n        if (face === \"U\") {\n          xyz = getUCoordinateByIndex(i);\n        } else if (face === \"D\") {\n          xyz = getDCoordinateByIndex(i);\n        } \n        else if (face === \"F\") { xyz = getFCoordinateByIndex(i); }\n        else if (face === \"B\") { xyz = getBCoordinateByIndex(i); }\n        else if (face === \"R\") { xyz = getRCoordinateByIndex(i); }\n        else if (face === \"L\") { xyz = getLCoordinateByIndex(i); }\n\n        const [x,y,z] = xyz;\n        // find the matching cubie\n        const cubie = findCubieByPosition(x,y,z);\n        if (cubie) {\n          cubie.colors[face] = colorString;\n        }\n      }\n    }\n    // fill in newState\n    setCubeState(newState);\n\n    // Also set a flag\n    //setShouldSolve(true);\n  }\n\n  \n    // 1) \"Find Solution\" button\n    const handleFindSolution = async () => {\n      const cubeString = flattenCubeStateByPosition(cubeState);\n  \n      try {\n        // Check for symmetry\n        const symmetryRes = await fetch(`${API_BASE_URL}/find_symmetry`, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ cube_data: cubeString }),\n        });\n        const symmetryData = await symmetryRes.json();\n  \n        if (!symmetryData.found) {\n          console.log(\"No symmetrical version found. Can't solve.\");\n          setSolutionSteps(null);\n          return;\n        }\n  \n        // If we got a symmetrical match, reorient the cube\n        if (symmetryData.state !== cubeString) {\n          reorientCubeFromString(symmetryData.state);\n          console.log(\"notice: cube switch to identical symmetic state - adapt your cube with this symmetrica state\")\n        }\n  \n        // Now request the solution steps from /solve\n        const solveRes = await fetch(`${API_BASE_URL}/solve`, {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ cube_data: symmetryData.state }),\n        });\n        const solveData = await solveRes.json();\n  \n        if (!solveData?.solution) {\n          console.log(\"No solution returned.\");\n          setSolutionSteps(null);\n          return;\n        }\n  \n        // Store the solution steps in state\n        setSolutionSteps(solveData.solution);\n        console.log(\"Solution steps are ready. Click 'Guide Me' to start solving.\");\n      } catch (err) {\n        console.error(\"Error finding or solving:\", err);\n      }\n    };\n  \n    // 2) \"Guide Me\" button\n    const handleGuideMe = () => {\n      if (!solutionSteps || solutionSteps.length === 0) {\n        console.log(\"No solution steps. Click 'Find Solution' first.\");\n        return;\n      }\n      // Start from the first move\n      setCurrentStepIndex(0);\n      showManualStep(0);\n    };\n    \n\n\n  // const guideUserThroughSolution = async (solutionMoves) => {\n  //   for (const layer of solutionMoves) {\n\n  //     if (layer === \"Congratulations!\") {\n  //       console.log(\"Done!\");\n  //       return;\n  //     }\n\n  //     let direction = 90;\n  //     if (layer === \"B\" || layer === \"L\") {\n  //       direction = -90;\n  //     }\n  //     // Show guidance with an arrow\n  //     showArrowOnFace(layer, direction);\n  \n  //     // Wait before animating the move\n  //     await delay(1000);  // 1-second pause before executing the move\n  \n  //     // Perform the rotation (animate and update state)\n  //     rotateLayerCubies(layer, direction);\n  \n  //     // Remove the arrow after the move\n  //     removeArrowFromFace(layer);\n  \n  //     // Wait before moving to the next step\n  //     await delay(1000);\n  //   }\n  \n  //   // Final success message\n  //   showSuccessMessage();\n  // };\n  \n\n  const showManualStep = (index) => {\n    // If we’re beyond the last move, show success\n    if (index >= solutionSteps.length) {\n      showSuccessMessage();\n      return;\n    }\n  \n    const layer = solutionSteps[index];\n    // If it's some special marker like \"Congratulations!\"\n    if (layer === \"Congratulations!\") {\n      showSuccessMessage();\n      return;\n    }\n  \n    // Determine arrow direction\n    let direction = 90;\n    if (layer === \"B\" || layer === \"L\") {\n      direction = -90;\n    }\n  \n    // Display the arrow on the correct face\n    showArrowsOnLayer(layer, direction);\n  \n    // Now we wait for the user to rotate manually...\n    // The user will click \"Next\" or some UI button once they’ve done the move\n  };\n\n  const handleUserRotationDone = () => {\n    // Remove the arrow from the current face\n    const layer = solutionSteps[currentStepIndex];\n    removeArrowsFromLayer(layer);\n  \n    // Move on to the next step\n    const nextIndex = currentStepIndex + 1;\n    setCurrentStepIndex(nextIndex);\n    showManualStep(nextIndex);\n  };\n  \n  \n\n  const showArrowsOnLayer = (layer, direction) => {\n    // Grab all .cubie-face elements whose data-face matches\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n  \n    faceElements.forEach((face) => {\n      // Create the arrow element\n      const arrow = document.createElement(\"div\");\n      arrow.classList.add(\"rotation-arrow\");\n      //arrow.classList.add(`rotation-arrow-${layer.toLowerCase()}`); // <--- add this line\n    \n      // Choose a symbol for clockwise vs. counterclockwise\n      if (layer == \"U\") {\n        arrow.innerHTML = direction < 0 ? \"↻\" : \"↺\";\n      } else {\n        arrow.innerHTML = direction > 0 ? \"↻\" : \"↺\";\n      }\n\n    \n      // Append the arrow to the face\n      face.appendChild(arrow);\n    });\n  };\n\n\n  \n\n  // Remove arrows from every face in that layer\n  const removeArrowsFromLayer = (layer) => {\n    const faceElements = document.querySelectorAll(`.cubie-face[data-face=\"${layer}\"]`);\n\n    faceElements.forEach((face) => {\n      const arrow = face.querySelector(\".rotation-arrow\");\n      if (arrow) arrow.remove();\n    });\n  };\n\n\n  const showSuccessMessage = () => {\n    const messageBox = document.createElement(\"div\");\n    messageBox.classList.add(\"success-message\");\n    messageBox.innerText = \"🎉 Cube Solved!\";\n    document.body.appendChild(messageBox);\n  \n    setTimeout(() => {\n      messageBox.remove(); // Remove after 3 seconds\n    }, 3000);\n  };\n  \n\n  const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n\n  // --- RENDERING ---\n  const renderCubies = () =>\n    cubeState.map((cubie) => {\n      const { id, position, colors } = cubie;\n      const [cx, cy, cz] = position;\n\n      return (\n        <div\n          key={id}\n          className=\"cubie\"\n          data-x={cx}     // So we can read them on click\n          data-y={cy}\n          data-z={cz}\n          style={{\n            position: \"absolute\",\n            width: \"88px\",\n            height: \"88px\",\n            transform: `translate3d(${cx * 45}px, ${-cy * 45}px, ${cz * 45}px)`,\n            transformStyle: \"preserve-3d\",\n          }}\n        >\n          {Object.entries(colors).map(([face, color]) => (\n            <div\n              key={face}\n              className=\"cubie-face\"\n              data-face={face} // e.g., \"U\", \"D\", \"F\", etc.\n              style={{\n                position: \"absolute\",\n                width: \"80px\",\n                height: \"80px\",\n                border: \"8px solid black\",\n                backgroundColor: color,\n                transform: getFaceTransform(face),\n                cursor: \"pointer\",\n              }}\n            />\n          ))}\n        </div>\n      );\n    });\n\n  // Places each face in the correct orientation\n  const getFaceTransform = (face) => {\n    switch (face) {\n      case \"U\":\n        return \"rotateX(90deg) translateZ(45px)\";\n      case \"D\":\n        return \"rotateX(-90deg) translateZ(45px)\";\n      case \"F\":\n        return \"translateZ(45px)\";\n      case \"B\":\n        return \"rotateY(180deg) translateZ(45px)\";\n      case \"L\":\n        return \"rotateY(-90deg) translateZ(45px)\";\n      case \"R\":\n        return \"rotateY(90deg) translateZ(45px)\";\n      default:\n        return \"\";\n    }\n  };\n\n\n\n  return (\n    <div>\n      <button onClick={scrambleCube}>Scramble</button> {/* Add the scramble button here */}\n      <button onClick={handleFindSolution}>Find Solution</button>\n      <button onClick={handleGuideMe}>Guide Me</button>\n      <button onClick={handleUserRotationDone}>Next Move</button>\n      <div\n        className=\"cube-container\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseLeave}\n        style={{ width: \"700px\", height: \"700px\", position: \"relative\" }}\n      >\n        <div\n          className=\"cube\"\n          style={{\n            transform: `rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`,\n            transformStyle: \"preserve-3d\",\n            position: \"absolute\",\n            width: \"100px\",\n            height: \"100px\",\n          }}\n        >\n          {renderCubies()}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Cube;  // Export the Cube component\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}